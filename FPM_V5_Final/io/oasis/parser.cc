// oasis/parser.cc -- semantic-level interface for reading OASIS files
//
// last modified:   12-Jun-2010  Sat  06:12
//
// Copyright (c) 2004 SoftJin Infotech Private Ltd.
// This software may be used only under the terms of the SoftJin
// Source License.  See the accompanying file LICENSE for details.

#include <sys/types.h>          // for off_t
#include <cctype>
#include <cstdarg>
#include <inttypes.h>
#include <limits>
#include <string>
#include <boost/static_assert.hpp>

#include "port/compiler.h"
#include "port/math.h"
#include "misc/arith.h"
#include "misc/utils.h"

#include "builder.h"
#include "dicts.h"
#include "infobyte.h"
#include "modal-vars.h"
#include "names.h"
#include "oasis.h"
#include "parser.h"
#include "rec-reader.h"
#include "rectypes.h"
#include "scanner.h"


namespace Oasis {

using namespace std;
using namespace SoftJin;


const Ulong  MaxLong = LONG_MAX;


// PropertyContext -- context in which PROPERTY record appears
//
// Appendix 2 of the spec defines some standard properties.  Each of
// these is valid in only one context, e.g., cell-level standard
// properties must appear after the corresponding CELLNAME record.
// The enumerators below define the different contexts in which a
// PROPERTY record may appear.
//
// Currently each standard property is valid in only one context, but
// we use a bitmask in case that changes.

enum PropertyContext {
    PC_File       = 0x01,
    PC_Cell       = 0x02,
    PC_Element    = 0x04,

    PC_CellName   = 0x08,
    PC_TextString = 0x10,
    PC_PropName   = 0x20,
    PC_PropString = 0x40,
    PC_LayerName  = 0x80,
    PC_XName      = 0x100
};



struct StdPropertyContext {
    const char* pname;              // name of standard property
    Uint        validContexts;      // OR or PC_* enumerators
};



const StdPropertyContext  stdPropertyContexts[] =
{
    // We make a linear search of the table, so the names are sorted in
    // decreasing order by frequency.  With this few names map<> and
    // HashMap<> are not worthwhile.

    { S_GDS_PROPERTY,                 PC_Element  },

    { S_CELL_OFFSET,                  PC_CellName },
    { S_BOUNDING_BOX,                 PC_CellName },

    { S_MAX_SIGNED_INTEGER_WIDTH,     PC_File     },
    { S_MAX_UNSIGNED_INTEGER_WIDTH,   PC_File     },
    { S_MAX_STRING_LENGTH,            PC_File     },
    { S_POLYGON_MAX_VERTICES,         PC_File     },
    { S_PATH_MAX_VERTICES,            PC_File     },
    { S_TOP_CELL,                     PC_File     },
    { S_BOUNDING_BOXES_AVAILABLE,     PC_File     },

    { Null, 0 }   // sentinel
};


/*----------------------------------------------------------------------

ParserImpl -- implementation of OasisParser

Data members:

parserOptions       OasisParserOptions

        Options passed to the constructor.

scanner             OasisScanner

        The parser uses the scanner only to read the magic string and to
        jump around the file.

recReader           OasisRecordReader

        Used for reading OASIS records from the file.  recReader uses
        the same scanner that this parser does.

warnHandler         WarningHandler

        Callback for warning messages generated by the parser or
        scanner.  Null if warnings are to be ignored.

builder             OasisBuilder*

        Its virtual methods will be invoked as pieces of the file are
        parsed.

modvars             ModalVars

        The values of the modal variables.

cellDict            CellDict

        Dictionary mapping CellName objects to Cell objects.  There is a
        Cell object for each CELL record in the file.  There is a
        CellName object for each name that appears in a CELL or CELLNAME
        record.

cellNameDict        CellNameDict
propNameDict        PropNameDict
propStringDict      PropStringDict
textStringDict      TextStringDict
xnameDict           XNameDict
layerNameDict       LayerNameDict

        Dictionaries for the six kinds of <name> records.  The
        dictionaries are used for checking for undefined names and
        duplicate names, and to map between names and reference-numbers.

unregPropNames      PointerVector<PropName>

        Owning vector for PropName objects created for PROPERTY records
        containing propname-strings.  These are not in propNameDict
        because they do not correspond to a PROPNAME record.  They do not
        have associated refnums and are not registered with OasisBuilder.
        makePropName() adds each name it creates to this vector.

unregTextStrings    PointerVector<TextString>

        Owning vector for TextString objects created for TEXT records
        containing text-strings.  These are not in textStringDict
        because they do not correspond to a TEXTSTRING record.  They do not
        have associated refnums and are not registered with OasisBuilder.
        makeTextString() adds each name it creates to this vector.

fileVersion         string
fileUnit            Oreal

        From the START record.  These are collected by parseStartRecord()
        and passed to OasisBuilder::beginFile().

fileValidation      Validation

        The validation scheme and signature from the END record.
        Initially fileValidation.scheme is Validation::None.  If
        parserOptions.wantValidation is true, parseEndRecord() stores
        the file's validation info here and then sets the flag
        haveValidation (see below) to indicate that it has done so.

currRecord          OasisRecord*

        The record currently being parsed.  Set by readNextRecord().  Is
        Null until the first call to readNextRecord() and is reset to
        Null by seekTo().  Used by abortParser() and warn() to show
        the error context.  Also used when the current record must be
        reread.

rereadCurrRecord    bool

        Set to true when the parser must push the current record back
        on the input stream.
        Invariant:  rereadCurrRecord => (currRecord != Null)

recordsSeen         Ullong

        Bit vector used by verifyExclusiveRecords() to implement mutual
        exclusion of the pairs of record types like RID_CELLNAME and
        RID_CELLNAME_R.  An OASIS file may contain only one of these
        record types.  Bit n of recordsSeen is set if record type n
        appeared in the file.  Bits are set only for the record types we
        care about, not for all the record types that appear in the file.

allNamesParsed      bool

        This flag is set by parseAllNames() at the end of the first
        phase of parsing, in which only <name> records (and possibly
        CELL records) are parsed.  When this is true, encountering a
        record with an undefined reference-number is a fatal error.

haveAllCellOffsets  bool

        This flag is set when all CELL records have been parsed.  It is
        used by the public parseCell() to see if the file contains a
        cell with the given name.  It is initialized to false and set
        to true by the methods that scan the whole file:
        parseFile(), parseAllNamesSequentially(), and getAllCellOffsets().

haveValidation      bool

        True means that the validation scheme and signature in the END
        record have been parsed and stored in the member fileValidation.
        parseEndRecord() sets this to true if parserOptions.wantValidation
        is true.

haveTableOffsets    bool

        True means that parseTableOffsets() has parsed table-offsets in
        the START or END record and saved the information in the
        dictionaries.  The START record has been parsed if this is true,
        regardless of which record contains the field.

propValuesToCheck   vector<PropValue*>

        Property values that contain unresolved references to PROPSTRING
        records.  Property values of types 13, 14, and 15 contain a
        propstring-reference-number, where the propstring referred to is
        implied to be an a-string, b-string, or n-string respectively.
        But we can check the string only if the PROPSTRING record has
        already been parsed.  If it hasn't, we append the PropValue
        object to propValuesToCheck so that we can check the string
        after all <name> records have been parsed.

        Note that even if the PROPSTRING table is strict we cannot avoid
        forward references by parsing all PROPSTRING records first.  The
        PROPSTRING records may have properties that reference other
        PROPSTRING records.

        checkPropertyValues() clears this vector after checking the
        values in it.

separatorPropName   PropName*

        The name for the dummy property that separates the properties of
        a CellName object obtained from different CELLNAME records.

        The spec allows multiple CELLNAME records with the same name and
        refnum.  We put the properties of all those records into a
        single PropertyList, but to implement the restrictions of
        paragraph 15.5 we need to know which properties in the list came
        from a single CELLNAME record.  So we temporarily insert dummy
        properties in the PropertyList to separate the properties from
        different CELLNAME records.

        See parseCellName() and parseStdCellNameProperties().

filename            string

        Pathname of file being parsed.

fileSize            Ullong

        Size of file being parsed.  Used to sanity-check the offsets
        that appear in the file -- the table offsets and S_CELL_OFFSET
        values.

------------------------------------------------------------------------*/


class ParserImpl {
    OasisScanner        scanner;
    OasisRecordReader   recReader;      // returns records one by one
    OasisParserOptions  parserOptions;
    WarningHandler      warnHandler;    // callback for warning messages
    OasisBuilder*       builder;
    ModalVars           modvars;        // store all modal variables

    // Dictionaries for cells and the six types of names.
    CellDict            cellDict;       // map from CellName* to Cell*
    CellNameDict        cellNameDict;
    PropNameDict        propNameDict;
    PropStringDict      propStringDict;
    TextStringDict      textStringDict;
    XNameDict           xnameDict;
    LayerNameDict       layerNameDict;

    // unregistered PropNames and TextStrings
    PointerVector<PropName>     unregPropNames;
    PointerVector<TextString>   unregTextStrings;

    // Information from START and END records
    string              fileVersion;    // from START record
    Oreal               fileUnit;       // from START record
    Validation          fileValidation; // from END record

    Ullong              recordsSeen;
    OasisRecord*        currRecord;             // current record being parsed
    bool                rereadCurrRecord;       // T => record was unread
    bool                allNamesParsed;         // all <name> records parsed
    bool                haveAllCellOffsets;     // all CELL records parsed
    bool                haveValidation;         // parsed validation in END
    bool                haveTableOffsets;       // parsed table-offsets
    vector<PropValue*>  propValuesToCheck;
    string              filename;
    Ullong              fileSize;
    PropName*           separatorPropName;

public:
                ParserImpl (const char* fname, WarningHandler warner,
                            const OasisParserOptions& options);
                ~ParserImpl();
    void        validateFile();
    Validation  parseValidation();
    void        parseFile (OasisBuilder* builder);
    bool        parseCell (const char* cellName, OasisBuilder* builder);

private:
    // Low-level utility methods

    OasisRecord*  readNextRecord();
    void        unreadLastRecord();
    long        ulongToLong (Ulong uval);
    void        seekTo (off_t offset);
    void        checkStrayNameRecord (const OasisDict& dict,
                                      const OasisRecord* orecp);
    void        checkInfoByte (int infoByte, int validBits);
    PropName*   makePropName (const string& name);
    TextString* makeTextString (const string& name);

    // Parsing START and END records

    void        parseStartAndEndRecords();
    void        parseStartRecord();
    void        parseEndRecord();
    void        parseTableOffsets (const TableOffsets& toffs);
    void        checkTableOffset (const TableOffsets::TableInfo& tinfo,
                                  const char* nameType);
    // Name-parsing phase

    void        parseAllNames();
    bool        canParseNamesDirectly();
    void        parseAllNamesDirectly();
    void        parseAllNamesSequentially();
    void        verifyAllNamesDefined();
    void        checkAllStdNameProperties();
    void        checkStdNameProperties(const OasisName* oname,
                                       const char* recName,
                                       enum PropertyContext ctxt);
    void        checkPropertyValues();
    void        registerAllNamesWithBuilder();

    // Parsing name tables

    void        parseCellNameTable();
    void        parseTextStringTable();
    void        parsePropNameTable();
    void        parsePropStringTable();
    void        parseLayerNameTable();
    void        parseXNameTable();

    // Each parseFooName() parses a <name> record and the following
    // PROPERTY records.

    void        parseCellName (NameRecord* recp);
    void        parseTextString (NameRecord* recp);
    void        parsePropName (NameRecord* recp);
    void        parsePropString (NameRecord* recp);
    void        parseLayerName (LayerNameRecord* recp);
    Interval    parseInterval (const LayerNameRecord::RawInterval& rawint);
    void        parseXName (XNameRecord* recp);

    // Parsing CELL records and their properties

    void        getAllCellOffsets();
    void        parseCell (CellRecord* recp);
    CellName*   parseCellRecord (CellRecord* recp);
    void        parseStdCellNameProperties();
    void        parseCellOffsetProperty (const CellName* cellName,
                                         const Property* prop);

    // Element-parsing functions.  Each parses an element record and
    // the following PROPERTY records.

    void        parsePlacement (const CellName* parentCell,
                                const PlacementRecord* recp);
    void        parseText (const TextRecord* recp);
    void        parseRectangle (const RectangleRecord* recp);
    void        parsePolygon (const PolygonRecord* recp);
    void        parsePath (const PathRecord* recp);
    void        parseTrapezoid (const TrapezoidRecord* recp);
    void        parseCTrapezoid (const CTrapezoidRecord* recp);
    void        parseCircle (const CircleRecord* recp);
    void        parseXElement (const XElementRecord* recp);
    void        parseXGeometry (const XGeometryRecord* recp);

    // Parsing PROPERTY records

    Uint        getStdPropertyContexts (const string& pname);
    void        parseNameProperties (OasisName* name);
    void        parsePropertiesForBuilder (enum PropertyContext ctxt);
    void        skipPropertyRecords();
    Property*   parsePropertyRecord (PropertyRecord* recp);
    void        fixPropValue (/*inout*/ PropValue* propval);

    // Parsing repetitions and point-lists

    Ulong       parseRepDimen (Ulong rawValue);
    void        parseRepetition (const RawRepetition& rawrep,
                                 /*out*/ Repetition* rep);
    void        parseRepetition2 (const RawRepetition& rawrep,
                                  /*out*/ Repetition* rep);
    void        parsePointList (const PointList&  rawPoints,
                                /*out*/ PointList* ptlist);
    void        parsePointList2 (const PointList&  rawPoints,
                                 /*out*/ PointList* ptlist);
    void        makePolygon (/*inout*/ PointList* ptlist);

    // Accessing the modal variables

    long        checkedPlus (long x, long y);
    long        getPlacementX (bool infoBit, long x);
    long        getPlacementY (bool infoBit, long y);
    long        getGeometryX (bool infoBit, long x);
    long        getGeometryY (bool infoBit, long y);
    long        getTextX (bool infoBit, long x);
    long        getTextY (bool infoBit, long y);
    Ulong       getLayer (bool infoBit, Ulong layer);
    Ulong       getDatatype (bool infoBit, Ulong datatype);
    Ulong       getTextlayer (bool infoBit, Ulong textlayer);
    Ulong       getTexttype (bool infoBit, Ulong texttype);
    Uint        getCTrapezoidType (bool infoBit, Ulong ctrapType);
    long        getGeometryWidth (bool infoBit, Ulong uwidth);
    long        getGeometryHeight (bool infoBit, Ulong uheight);
    long        getPathHalfwidth (bool infoBit, Ulong uhalfwidth);
    long        getRadius (bool infoBit, Ulong uradius);
    long        getStartExtension (Uint selector, long halfwidth, long extn);
    long        getEndExtension (Uint selector, long halfwidth, long extn);
    CellName*   getPlacementCell (bool isExplicit, bool isRefnum,
                                  const string& name, Ulong refnum);
    TextString* getTextString (bool isExplicit, bool isRefnum,
                               const string& text, Ulong refnum);
    PropName*   getPropName (bool isExplicit, bool isRefnum,
                             const string& name, Ulong refnum);
    const PointList&    getPolygonPoints (bool infoBit,
                                          const PointList& rawPoints);
    const PointList&    getPathPoints (bool infoBit,
                                       const PointList& rawPoints);
    const Repetition*   getRepetition (bool infoBit,
                                       const RawRepetition& rawrep);
    void        xyRelative (bool yes);

    // Performing validity checks

    void        verifyStringIsAscii (const string& str);
    void        verifyStringIsName (const string& str);
    void        verifyExclusiveRecords (Uint currRecID,
                                        RecordID rid, RecordID rid2);
    // Handling errors

    void        mvAbort (const char* varName) SJ_NORETURN;
    void        abortParser (const char* fmt, ...)
                                             SJ_PRINTF_ARGS(2,3) SJ_NORETURN;
    void        warn (const char* fmt, ...)  SJ_PRINTF_ARGS(2,3);
    void        formatMessage (/*out*/ char* buf, size_t bufsize,
                               const char*  msgPrefix,
                               const char*  fmt,
                               va_list  ap);
private:
                ParserImpl (const ParserImpl&);         // forbidden
    void        operator= (const ParserImpl&);          // forbidden
};



// constructor
//   fname      pathname of file to parse
//   warner     callback to be invoked for warning messages.
//              Must accept a const char* argument, the warning message.
//              If Null, warnings are ignored.
//   options    options controlling how strict to be and whether any
//              records should be ignored

ParserImpl::ParserImpl (const char* fname, WarningHandler warner,
                        const OasisParserOptions& options)
  : scanner(fname, warner),
    recReader(scanner),
    parserOptions(options),
    warnHandler(warner),
    filename(fname)
{
    scanner.verifyMagic();      // abort unless file begins with magic string
    builder = Null;
    currRecord = Null;
    rereadCurrRecord = false;
    allNamesParsed = false;     // set by parseAllNames()
    haveAllCellOffsets = false;
    haveTableOffsets = false;   // set by parseTableOffsets()
    haveValidation = false;     // set by parseEndRecord(), but not always
    recordsSeen = 0;
    fileSize = scanner.getFileSize();
    fileValidation.scheme = Validation::None;

    separatorPropName = makePropName("*");      // the name is arbitrary
    recReader.setValidationWanted(parserOptions.wantValidation);
}


ParserImpl::~ParserImpl() { }


//----------------------------------------------------------------------
//                       Low-level private methods
//----------------------------------------------------------------------

// readNextRecord -- read next record or reread previous record.
// This function ignores PAD records and CBLOCK records.

OasisRecord*
ParserImpl::readNextRecord()
{
    // If unreadLastRecord() was called after the last call to
    // readNextRecord(), return the previous call's record once again.
    // Otherwise read a record, skipping PAD and CBLOCK.  We don't have
    // to do anything for CBLOCKs because OasisRecordReader invokes the
    // scanner's decompressor.

    if (rereadCurrRecord)
        rereadCurrRecord = false;
    else {
        OasisRecord*  orecp;
        do {
            orecp = recReader.getNextRecord();
        } while (orecp->recID == RID_PAD  ||  orecp->recID == RID_CBLOCK);
        currRecord = orecp;
    }
    return currRecord;
}



// unreadLastRecord -- return the last record read to the input.
// The next call to readNextRecord() will return the same record that it
// returned the previous time.  In OASIS, sequences of records do not
// have terminators.  You know you have reached the end of the sequence
// only when you read a record type that does not belong to the
// sequence.  You then have to unread that record.
//
// Precondition:
// There must have been an earlier call to readNextRecord() without
// an intervening call to seekTo() or unreadLastRecord().  That is,
// there must a record to unread.

inline void
ParserImpl::unreadLastRecord() {
    assert (currRecord != Null  &&  !rereadCurrRecord);
    rereadCurrRecord = true;
}



// ulongToLong -- convert Ulong to long, checking that number is within range.
// OASIS uses unsigned-integers for dimensions like width, height, and
// radius.  When the application uses these dimensions, it will probably
// need to add them to the (signed) x,y position.  Because it is easier
// to check for integer overflow if the dimension is also signed, the
// parser uses (signed) longs for these quantities.  The functions that
// parse dimensions call ulongToLong() to ensure that the dimension fits
// into a long.

inline long
ParserImpl::ulongToLong (Ulong uval)
{
    if (uval > MaxLong)
        abortParser("value %lu too large to handle", uval);
    return static_cast<long>(uval);
}



// seekTo -- jump to the given offset in the file

void
ParserImpl::seekTo (off_t offset)
{
    scanner.seekTo(offset);
    rereadCurrRecord = false;
    currRecord = Null;
}



// checkStrayNameRecord -- see if <name> record lies outside strict-mode table.
//   dict       dictionary for the name table
//   orecp      the <name> record
// parseFile() calls this in the second phase of parsing to implement
// the check in paragraph 13.10 of the spec.  As allowed by 13.10, we
// enforce the strictness only if we made use of it through
// parseAllNamesDirectly().  None of the dictionaries' enforceStrict
// flags is set if parseAllNamesSequentially() scanned the whole file.

inline void
ParserImpl::checkStrayNameRecord (const OasisDict& dict,
                                  const OasisRecord* orecp)
{
    if (dict.enforceStrict()  &&  ! dict.containsPosition(orecp->recPos))
        abortParser("stray record outside strict-mode table");
}



// checkInfoByte -- verify that none of the unused bits in an info-byte is set
//   infoByte   the info-byte value in the record
//   validBits  bit mask containing 1s in all the valid bits
//
// The info-byte fields in TEXT, POLYGON, and CIRCLE records have one or
// two bits that must be 0.  The parsing functions for these record types
// call this function to verify that.

inline void
ParserImpl::checkInfoByte (int infoByte, int validBits)
{
    if (parserOptions.strictConformance  &&  (infoByte & ~validBits) != 0) {
        abortParser("invalid info-byte %#x; bit(s) %#x must be 0",
                    infoByte, infoByte & ~validBits);
    }
}



// makePropName -- create and return an unregistered PropName object.
// Adds the name to unregPropNames so that ~ParserImpl() will delete it.

inline PropName*
ParserImpl::makePropName (const string& name)
{
    auto_ptr<PropName>  apn(new PropName(name));
    unregPropNames.push_back(apn.get());
    return apn.release();
}



// makeTextString -- create and return an unregistered TextString object.
// Adds the name to unregTextStrings so that ~ParserImpl() will delete it.

inline TextString*
ParserImpl::makeTextString (const string& name)
{
    auto_ptr<TextString>  ats(new TextString(name));
    unregTextStrings.push_back(ats.get());
    return ats.release();
}



// IsPropertyRecord -- true if the input record is a PROPERTY record
// Convenience function for reading property lists.

inline bool
IsPropertyRecord (const OasisRecord* orecp) {
    return (orecp->recID == RID_PROPERTY
            ||  orecp->recID == RID_PROPERTY_REPEAT);
}



//----------------------------------------------------------------------
//                              Public methods
//----------------------------------------------------------------------

// validateFile -- check that the file's CRC/checksum matches the stored value
// Does nothing if the file's validation scheme is None.
// Throws an exception if the validation fails.

void
ParserImpl::validateFile()
{
    // Set recReader's wantValidation option to tell it to read the
    // validation info too.  Although the flag needs to be set just for
    // this call, there is no harm in setting it permanently.  If we
    // successfully parse the validation info now, we will always
    // succeed.

    recReader.setValidationWanted(true);
    parseStartAndEndRecords();
    scanner.validateFile(fileValidation);
}



// parseValidation -- return validation info from END record

Validation
ParserImpl::parseValidation()
{
    recReader.setValidationWanted(true);
    parseStartAndEndRecords();
    return fileValidation;
}



// parseFile -- parse the entire file
//   builder    its virtual methods will be invoked as each piece of
//              the input file is recognized
// Throws runtime_error if an unrecoverable error occurs.

void
ParserImpl::parseFile (OasisBuilder* builder)
{
    // 6.2
    // <oasis-file> ::= <magic-bytes> START
    //                  { CBLOCK | PAD | PROPERTY | <cell> | <name> }* END
    // <name>       ::= { CELLNAME | TEXTSTRING | LAYERNAME | PROPNAME |
    //                    PROPSTRING | XNAME }

    // In the first pass of the file, parse only the <name> records.
    // See the entry on parser architecture in DesignNotes for why we
    // use two passes.  The offsets of the name tables are in either
    // the START record or the END record, so parse those first.

    this->builder = builder;
    parseStartAndEndRecords();
    parseAllNames();

    // Return to the beginning of the file for the second (main) pass,
    // in which we parse all the cells.

    seekTo(StartRecordOffset);
    (void) readNextRecord();            // already parsed START record
    builder->beginFile(fileVersion, fileUnit, fileValidation.scheme);

    // Pass all registered names in all the dictionaries to the builder
    // by invoking its different registerFooName() methods.

    registerAllNamesWithBuilder();

    // Parse the file-level properties, if any.  These must directly
    // follow the START record (spec 31.8).

    parsePropertiesForBuilder(PC_File);

    // Parse the cells.  The switch does not have cases for RID_CBLOCK
    // and RID_PAD because readNextRecord() handles them.

    OasisRecord*  orecp;
    while (orecp = readNextRecord(), orecp->recID != RID_END) {
        switch (orecp->recID) {
            case RID_CELL_REF:
            case RID_CELL_NAMED:
                parseCell(static_cast<CellRecord*>(orecp));
                break;

            // Ignore the contents of <name> records because
            // parseAllNames() already parsed them.  But we still need to
            // detect stray records if we used the table strictness to
            // jump directly to the table to parse it (13.10).

            case RID_CELLNAME:
            case RID_CELLNAME_R:
                checkStrayNameRecord(cellNameDict, orecp);
                break;

            case RID_TEXTSTRING:
            case RID_TEXTSTRING_R:
                if (parserOptions.wantText)
                    checkStrayNameRecord(textStringDict, orecp);
                break;

            case RID_PROPNAME:
            case RID_PROPNAME_R:
                checkStrayNameRecord(propNameDict, orecp);
                break;

            case RID_PROPSTRING:
            case RID_PROPSTRING_R:
                checkStrayNameRecord(propStringDict, orecp);
                break;

            case RID_LAYERNAME_GEOMETRY:
            case RID_LAYERNAME_TEXT:
                if (parserOptions.wantLayerName)
                    checkStrayNameRecord(layerNameDict, orecp);
                break;

            case RID_XNAME:
            case RID_XNAME_R:
                if (parserOptions.wantExtensions)
                    checkStrayNameRecord(xnameDict, orecp);
                break;

            // Ignore PROPERTY records seen here.  They can belong only
            // to <name> records, so we have already parsed them.

            case RID_PROPERTY:
            case RID_PROPERTY_REPEAT:
                break;

            default:
                abortParser("expecting CELL or <name> record here");
        }
    }
    haveAllCellOffsets = true;
    builder->endFile();
}



// parseCell -- parse one cell in the input file
//   name       name of cell
//   builder    its virtual methods will be invoked as each piece of
//              the cell is recognized
// Returns true on success, false if the file has no cell with the
// given name.  Throws runtime_error if an unrecoverable error occurs.
//
// Note that parseCell() is overloaded; the private parseCell() that
// this method invokes does the real work.

bool
ParserImpl::parseCell (const char* name, OasisBuilder* builder)
{
    // As in parseFile(), we need to parse all the name records first.
    // Both these functions do nothing if they have already been invoked.

    parseStartAndEndRecords();
    parseAllNames();

    // If the cellname table is strict, we will have a CellName object
    // for the cell because every CELL record must reference a CELLNAME
    // record.  If the cellname table is not strict, parseAllNames()
    // will have scanned the whole file and created CellName and Cell
    // objects for each CELL record.  Hence if there is a cell with the
    // given name, we must have a CellName object for it.

    CellName*  cellName = cellNameDict.lookupName(name, false);
    if (cellName == Null)
        return false;

    // Get the Cell object from the CellName.  If we don't have it, or
    // if it doesn't have the offset, it is because the cellname table
    // was strict but the CELLNAME record for the cell did not contain
    // the S_CELL_OFFSET property.  We have no option now but to scan
    // the file sequentially, recording the actual offset of each CELL
    // record.  If even after doing that we don't have a Cell object
    // with the given name, the file has no such cell.

    Cell*  cell = cellDict.lookup(cellName, false);
    if (cell == Null  ||  ! cell->haveOffset())
        getAllCellOffsets();
    if ((cell = cellDict.lookup(cellName, false)) == Null
            ||  ! cell->haveOffset())
        return false;

    // A cell is external (defined elsewhere) if its CELLNAME record has
    // an S_CELL_OFFSET property with the value 0.  (spec A2-2.3)

    off_t  cellOffset = cell->getOffset();
    if (cellOffset == 0)
        return false;

    // Jump to the cell location in the file and start parsing.

    seekTo(cellOffset);
    OasisRecord*  orecp = readNextRecord();
    if (orecp->recID != RID_CELL_NAMED  &&  orecp->recID != RID_CELL_REF)
        abortParser("cell %s does not begin with CELL record", name);

    this->builder = builder;
    parseCell(static_cast<CellRecord*>(orecp));
    return true;
}


//----------------------------------------------------------------------
//                          START and END records
//----------------------------------------------------------------------

// parseStartAndEndRecords -- parse START and END if not already parsed.
// The contents of both records are saved in class members.
//
// All public ParserImpl methods call this method first.  Normally both
// records must be parsed before all the name records because the
// table-offsets field, which gives the file offsets of the name tables,
// may appear in the START or in the END record.
//
// Postconditions:
//   haveTableOffsets
//   wantValidation => haveValidation

void
ParserImpl::parseStartAndEndRecords()
{
    // Parse the records only on the first call.  The END record can be
    // ignored if table-offsets is in the START record and the
    // validation data is not wanted.

    if (! haveTableOffsets)
        parseStartRecord();
    if (! haveTableOffsets
            ||  (parserOptions.wantValidation && !haveValidation))
        parseEndRecord();
}



void
ParserImpl::parseStartRecord()
{
    // Section 13:  START record
    // `1' version-string unit offset-flag [table-offsets]

    StartRecord*  recp = recReader.getStartRecord();
    currRecord = recp;

    // Check that the file format is "1.0", the version that this
    // implementation supports.  Although it is risky to parse a
    // new-format file with an old parser, an OASIS test suite says
    // that a version mismatch should not be a fatal error.  So just
    // warn instead of aborting.
    //
    // When parserOptions.strictConformance is false we allow control
    // chars in ascii-strings.  So we need to construct a printable
    // representation of the version for the error message.

    verifyStringIsAscii(recp->version);
    if (recp->version != "1.0") {
        char  buf[256];
        MakePrintableString(recp->version.c_str(), recp->version.size(),
                            buf, sizeof(buf));
        warn("the file has OASIS version '%s' but this parser is for "
             "OASIS 1.0", buf);
    }
    fileVersion = recp->version;

    double  unitVal = recp->unit.getValue();
    if (!isfinite(unitVal)  ||  unitVal <= 0.0)
        abortParser("invalid unit %.15g", unitVal);
    fileUnit = recp->unit;

    if (parserOptions.strictConformance  &&  recp->offsetFlag > 1)
        abortParser("offset-flag has non-standard value %lu", recp->offsetFlag);
    if (recp->offsetFlag == 0)
        parseTableOffsets(recp->offsets);
}



void
ParserImpl::parseEndRecord()
{
    // Section 14:  END record
    // `2' [table-offsets] padding-string validation-scheme
    //     [validation-signature]

    EndRecord*  recp = recReader.getEndRecord();
    currRecord = recp;

    // The table offsets appear in the END record only if they were not
    // there in the START record.  EndRecord's offsetFlag is copied from
    // StartRecord.

    if (recp->offsetFlag != 0)
        parseTableOffsets(recp->offsets);

    if (! parserOptions.wantValidation)
        return;
    switch (recp->valScheme) {
        case Validation::None:
        case Validation::CRC32:
        case Validation::Checksum32:
            // Nothing to do
            break;
        default:
            abortParser("invalid validation scheme %lu", recp->valScheme);
    }

    fileValidation.scheme = static_cast<Validation::Scheme>(recp->valScheme);
    fileValidation.signature = recp->valSignature;
    haveValidation = true;

    // The scanner should now be at EOF.  But some OASIS files have a
    // padding string that is too short and garbage after the validation
    // signature (unconfirmed customer report).  So verify this only
    // when insisting on strict conformance.

    if (parserOptions.strictConformance  &&  ! scanner.eof())
        abortParser("END record is too small");
}



// parseTableOffsets -- parse table-offsets field in START or END record

void
ParserImpl::parseTableOffsets (const TableOffsets& toffs)
{
    // The table-offsets field consists of 6 pairs of unsigned-integers
    // (strict-flag, offset), one pair for each table.  strict-flag
    // should be 1 for strict tables or 0 for non-strict tables.
    //
    // When parserOptions.strictConformance is false we treat all
    // non-zero flag values like 0.  This is safer but slower than
    // treating them as 1 because it means that the parser will make an
    // extra pass to collect all <name> records.

    checkTableOffset(toffs.cellName, "cellname");
    cellNameDict.setStrict(toffs.cellName.strict == 1);
    cellNameDict.setStartOffset(toffs.cellName.offset);

    checkTableOffset(toffs.textString, "textstring");
    textStringDict.setStrict(toffs.textString.strict == 1);
    textStringDict.setStartOffset(toffs.textString.offset);

    checkTableOffset(toffs.propName, "propname");
    propNameDict.setStrict(toffs.propName.strict == 1);
    propNameDict.setStartOffset(toffs.propName.offset);

    checkTableOffset(toffs.propString, "propstring");
    propStringDict.setStrict(toffs.propString.strict == 1);
    propStringDict.setStartOffset(toffs.propString.offset);

    checkTableOffset(toffs.layerName, "layername");
    layerNameDict.setStrict(toffs.layerName.strict == 1);
    layerNameDict.setStartOffset(toffs.layerName.offset);

    checkTableOffset(toffs.xname, "xname");
    xnameDict.setStrict(toffs.xname.strict == 1);
    xnameDict.setStartOffset(toffs.xname.offset);

    haveTableOffsets = true;
}



// checkTableOffset -- sanity-check a table offset value
//   tinfo      the strict flag and offset of the table entry to check
//   nameType   which table the offset is for, for error message
// Helper function for parseTableOffsets() above.

void
ParserImpl::checkTableOffset (const TableOffsets::TableInfo& tinfo,
                              const char* nameType)
{
    if (parserOptions.strictConformance  &&  tinfo.strict > 1) {
        abortParser("%s-flag has non-standard value %lu",
                    nameType, tinfo.strict);
    }
    if (parserOptions.strictConformance  &&  tinfo.offset >= fileSize) {
        abortParser("%s-offset %llu is beyond the end of the file",
                    nameType, tinfo.offset);
    }

    // tinfo.offset has type Ullong but OasisDict stores the offset in
    // an off_t member.  We have to ensure it can do that regardless of
    // strictConformance.

    const Ullong  MaxOffset = numeric_limits<off_t>::max();
    if (tinfo.offset > MaxOffset) {
        abortParser("%s-offset %llu is too large to store",
                    nameType, tinfo.offset);
    }
}



//----------------------------------------------------------------------
//                           Name-parsing phase
//----------------------------------------------------------------------

// parseAllNames -- parse all <name> records and associated PROPERTY records.
// Precondition:
//    The START and END records must have been parsed.  We need the
//    info in the table-offsets field of those records.

void
ParserImpl::parseAllNames()
{
    // This function may be called several times.
    if (allNamesParsed)
        return;

    // If all name records of each kind are grouped together in tables,
    // we can jump directly to each table and parse the name records in
    // it.  Otherwise we must do it the hard way -- by reading the file
    // from beginning to end looking for name records.

    if (canParseNamesDirectly())
        parseAllNamesDirectly();
    else
        parseAllNamesSequentially();

    // Reset currRecord and rereadCurrRecord.  We don't want
    // abortParser() to print some random record as the context if any
    // of the calls below results in an abort.

    seekTo(StartRecordOffset);

    // Verify things we left pending for forward references.
    // verifyAllNamesDefined() must be called before the other two.
    // checkAllStdNameProperties() assumes that all names are defined,
    // and checkPropertyValues() assumes that all PropStrings are
    // defined.
    //
    // Reset currRecord and rereadCurrRecord before the checks.  We
    // don't want abortParser() to print some random record as the
    // context if any of the checks results in an abort.

    currRecord = Null;
    rereadCurrRecord = false;
    verifyAllNamesDefined();
    checkAllStdNameProperties();
    checkPropertyValues();

    // Get the value in each CellName's S_CELL_OFFSET property and store
    // in the corresponding Cell.

    parseStdCellNameProperties();

    allNamesParsed = true;
}



// canParseNamesDirectly -- true iff all name tables we care about are strict

bool
ParserImpl::canParseNamesDirectly()
{
    if (!cellNameDict.isStrict()
            || !propNameDict.isStrict()
            || !propStringDict.isStrict())
        return false;

    // Many applications are not interested in TEXT (and hence
    // TEXTSTRING), LAYERNAME, and XNAME records.  We do not need a
    // separate pass for names if only those tables are non-strict.

    if (!textStringDict.isStrict() && parserOptions.wantText)
        return false;
    if (!layerNameDict.isStrict() && parserOptions.wantLayerName)
        return false;
    if (!xnameDict.isStrict() && parserOptions.wantExtensions)
        return false;

    return true;
}



// parseAllNamesDirectly -- parse each name table by jumping directly to it.
// Precondition:
//     All name tables are strict.

void
ParserImpl::parseAllNamesDirectly()
{
    // Because we jump directly to each table, stray records (those
    // outside the table) will never be parsed because we will see
    // them only in the second phase, when all <name> records are
    // ignored.  So we must enforce the edict against strays (13.10).

    // Parse the PROPNAME and PROPSTRING tables first to minimize
    // forward references.

    parsePropNameTable();
    propNameDict.enforceStrict(true);

    parsePropStringTable();
    propStringDict.enforceStrict(true);

    parseCellNameTable();
    cellNameDict.enforceStrict(true);

    if (parserOptions.wantText) {
        parseTextStringTable();
        textStringDict.enforceStrict(true);
    }
    if (parserOptions.wantLayerName) {
        parseLayerNameTable();
        layerNameDict.enforceStrict(true);
    }
    if (parserOptions.wantExtensions) {
        parseXNameTable();
        xnameDict.enforceStrict(true);
    }
}



// parseAllNamesSequentially -- scan whole file looking for <name> records.
//
// We also parse all the CELL records (but not their following PROPERTY
// records).  Since we are anyway going through the file, we might as
// well collect all the offsets of the CELL records.  We need the
// offsets to jump to a specific cell if application calls parseCell().
// We cannot depend on the S_CELL_OFFSET properties of CELLNAME records
// because they are optional.
//
// Note that this function does not invoke OasisDict::enforceStrict()
// for any of the tables, even those that are strict.  We don't need to
// worry about strays because we are scanning the whole file.  Also,
// before calling a dictionary's enforceStrict() we would have to set
// its end position; finding that would be a hassle here.

void
ParserImpl::parseAllNamesSequentially()
{
    OasisRecord*  orecp;

    seekTo(StartRecordOffset);
    while (orecp = readNextRecord(), orecp->recID != RID_END) {
        switch (orecp->recID) {
            case RID_CELL_NAMED:
            case RID_CELL_REF:
                parseCellRecord(static_cast<CellRecord*>(orecp));
                break;

            case RID_CELLNAME:
            case RID_CELLNAME_R:
                parseCellName(static_cast<NameRecord*>(orecp));
                break;

            case RID_TEXTSTRING:
            case RID_TEXTSTRING_R:
                if (parserOptions.wantText)
                    parseTextString(static_cast<NameRecord*>(orecp));
                break;

            case RID_PROPNAME:
            case RID_PROPNAME_R:
                parsePropName(static_cast<NameRecord*>(orecp));
                break;

            case RID_PROPSTRING:
            case RID_PROPSTRING_R:
                parsePropString(static_cast<NameRecord*>(orecp));
                break;

            case RID_LAYERNAME_GEOMETRY:
            case RID_LAYERNAME_TEXT:
                if (parserOptions.wantLayerName)
                    parseLayerName(static_cast<LayerNameRecord*>(orecp));
                break;

            case RID_XNAME:
            case RID_XNAME_R:
                if (parserOptions.wantExtensions)
                    parseXName(static_cast<XNameRecord*>(orecp));
                break;

            default:    // avoid complaint about unused enumerators
                break;
        }
    }
    haveAllCellOffsets = true;
}



// verifyAllNamesDefined -- ensure all forward references are resolved.
// parseAllNames() invokes this at the end of the first phase of
// parsing.  During the name-parsing phase we may have forward
// references, in which a record uses a reference-number to refer to a
// <name> record that has not yet been seen.  This can happen for two
// reasons.
//
// 1.  We parse the PROPERTY records associated with each <name> record
// immediately after parsing the <name> record.  These PROPERTY records
// may contain propname-refnums and propstring-refnums that are
// forward references.
//
// 2.  parseAllNamesSequentially() parses CELL records (to collect their
// offsets) along with the <name> records.  These CELL records may have
// forward references (refnums) to CELLNAME records.
//
// If during the first phase a parsing function sees a refnum for which
// no PropName, PropString, or CellName object exists, it creates a
// placeholder temporarily-nameless object and maps the refnum to that.
// The name is filled in later when the corresponding PROPNAME,
// PROPSTRING, or CELLNAME record is seen.  So at the end of the first
// phase we must verify that every name object really has a name.

void
ParserImpl::verifyAllNamesDefined()
{
    // Verify that every registered PropName has a name, i.e., it has
    // been defined by a PROPNAME record.  Note that we need not use the
    // two-argument version of getRefnum() because every PropName
    // without a name must have a refnum.  That is why it exists.

    PropNameDict::iterator  propNameIter = propNameDict.begin();
    PropNameDict::iterator  propNameEnd  = propNameDict.end();
    for ( ;  propNameIter != propNameEnd;  ++propNameIter) {
        PropName*  propName = *propNameIter;
        if (! propName->hasName())
            abortParser("PROPNAME reference-number %lu not defined",
                        propNameDict.getRefnum(propName));
    }

    // Verify that every PropString has been defined by a PROPSTRING
    // record.

    PropStringDict::iterator  stringIter = propStringDict.begin();
    PropStringDict::iterator  stringEnd  = propStringDict.end();
    for ( ;  stringIter != stringEnd;  ++stringIter) {
        PropString*  propString = *stringIter;
        if (! propString->hasName())
            abortParser("PROPSTRING reference-number %lu not defined",
                        propStringDict.getRefnum(propString));
    }

    // Verify that every CellName has been defined by a CELLNAME record.

    CellNameDict::iterator  cellNameIter = cellNameDict.begin();
    CellNameDict::iterator  cellNameEnd  = cellNameDict.end();
    for ( ;  cellNameIter != cellNameEnd;  ++cellNameIter) {
        CellName*  cellName = *cellNameIter;
        if (! cellName->hasName())
            abortParser("CELLNAME reference-number %lu not defined",
                        cellNameDict.getRefnum(cellName));
    }
}



// checkAllStdNameProperties -- check that std properties are correctly used
//
// parseAllNames() calls this to ensure that the standard properties on
// <name> records are valid.  Because of forward references we can do this
// only at the end of the first pass.
//
// File, cell, and element properties are parsed in the second pass.
// All names are available then, so parsePropertiesForBuilder() checks
// those immediately after parsing the PROPERTY record.
//
// The checks are disabled when parserOptions.strictConformance is
// false.  This is because an old version of another tool generates
// invalid files in which a PROPERTY record for the S_TOP_CELL file
// property follows a PROPSTRING record.  Here is a sample:
//
//     START "1.0" 1000.0 0 0 0 0 0 0 0 0 0 0 0 0 0
//     PROPNAME "S_TOP_CELL"
//     PROPSTRING "top"
//     PROPERTY 0x17  refnum 0  standard  values 1 15 0
//
// The PROPERTY record must appear immediately after START because the
// intent is to set the file property S_TOP_CELL to "top".  But because
// the PROPERTY record appears after the PROPSTRING record, the property
// is attached to the PROPSTRING instead of the file.
//
// Precondition:
// verifyAllNamesDefined() was called earlier to verify that all
// OasisName objects have names.

void
ParserImpl::checkAllStdNameProperties()
{
    if (! parserOptions.strictConformance)
        return;

    // Note that we cannot merge these loops with those in
    // registerAllNamesWithBuilder() because that function is not
    // called when only one cell in the file is parsed.

    CellNameDict::const_iterator  cellNameIter = cellNameDict.begin();
    CellNameDict::const_iterator  cellNameEnd  = cellNameDict.end();
    for ( ;  cellNameIter != cellNameEnd;  ++cellNameIter)
        checkStdNameProperties(*cellNameIter, "CELLNAME", PC_CellName);

    TextStringDict::const_iterator  textStringIter = textStringDict.begin();
    TextStringDict::const_iterator  textStringEnd  = textStringDict.end();
    for ( ;  textStringIter != textStringEnd;  ++textStringIter)
        checkStdNameProperties(*textStringIter, "TEXTSTRING", PC_TextString);

    PropNameDict::const_iterator  propNameIter = propNameDict.begin();
    PropNameDict::const_iterator  propNameEnd  = propNameDict.end();
    for ( ;  propNameIter != propNameEnd;  ++propNameIter)
        checkStdNameProperties(*propNameIter, "PROPNAME", PC_PropName);

    PropStringDict::const_iterator  propStringIter = propStringDict.begin();
    PropStringDict::const_iterator  propStringEnd  = propStringDict.end();
    for ( ;  propStringIter != propStringEnd;  ++propStringIter)
        checkStdNameProperties(*propStringIter, "PROPSTRING", PC_PropString);

    LayerNameDict::const_iterator  layerNameIter = layerNameDict.begin();
    LayerNameDict::const_iterator  layerNameEnd  = layerNameDict.end();
    for ( ;  layerNameIter != layerNameEnd;  ++layerNameIter)
        checkStdNameProperties(*layerNameIter, "LAYERNAME", PC_LayerName);

    XNameDict::const_iterator  xnameIter = xnameDict.begin();
    XNameDict::const_iterator  xnameEnd  = xnameDict.end();
    for ( ;  xnameIter != xnameEnd;  ++xnameIter)
        checkStdNameProperties(*xnameIter, "XNAME", PC_XName);
}



// checkStdNameProperties -- check std properties of name are correctly used
//   oname      the OasisName whose properties are to be checked
//   recName    the type of name (e.g. "CELLNAME") for the error message
//   ctxt       enumerator that also identifies the type of name
//
// checkStdNameProperties() verifies that each property of oname that is
// claimed to be standard has a name that is standard and is allowed to
// belong to <name> records of the given type.
//
// Note that this function is called only when
// parserOptions.strictConformance is true.

void
ParserImpl::checkStdNameProperties (const OasisName* oname,
                                    const char* recName,
                                    enum PropertyContext ctxt)
{
    PropertyList::const_iterator  iter = oname->getPropertyList().begin();
    PropertyList::const_iterator  end  = oname->getPropertyList().end();
    for ( ;  iter != end;  ++iter) {
        const Property*  prop = *iter;
        if (! prop->isStandard())
            continue;

        const string&  pname = prop->getName()->getName();
        Uint  validContexts = getStdPropertyContexts(pname);
        if ((validContexts & ctxt) != 0)
            continue;

        char  nameBuf[100];
        const string&  name = oname->getName();
        MakePrintableString(name.data(), name.size(), nameBuf, sizeof(nameBuf));
        const char*  fmt;
        if (validContexts == 0)
            fmt = "%s '%s' has standard property with non-standard name '%s'";
        else
            fmt = "%s '%s' has misplaced standard property: "
                  "'%s' is not valid in this context";
        abortParser(fmt, recName, nameBuf, pname.c_str());
    }
}



// checkPropertyValues -- check the values of pending PropString PropValues.
// For each property value in propValuesToCheck, verify that the string
// in the PropString really is an a-string or an n-string if the type of
// property value indicates that it is.  fixPropValue() could not verify
// this when the PROPERTY record was parsed because the PROPSTRING
// record with the value had not yet been seen.
//
// parseAllNames() calls this at the end of the first phase, when all
// <name> records have been parsed.
//
// Precondition:
// verifyAllNamesDefined() was called earlier to verify that all
// PropString objects have names, i.e., that all propstring-refnums
// have been defined by PROPSTRING records.

void
ParserImpl::checkPropertyValues()
{
    vector<PropValue*>::iterator  valIter = propValuesToCheck.begin();
    vector<PropValue*>::iterator  valEnd  = propValuesToCheck.end();
    for ( ;  valIter != valEnd;  ++valIter) {
        PropValue*  propval = *valIter;
        switch (propval->getType()) {
            case PV_Ref_AsciiString:
                verifyStringIsAscii(propval->getStringValue());
                break;
            case PV_Ref_NameString:
                verifyStringIsName(propval->getStringValue());
                break;
            default:    // avoid complaints from gcc about unused enumerators
                break;
        }
    }

    // The contents of propValuesToCheck are no longer needed.
    // Clear it and free the vector's internal array.

    vector<PropValue*>().swap(propValuesToCheck);
}



// registerAllNamesWithBuilder -- invoke builder's registerFooName() methods.
// Registers with the builder all the name objects that have been
// registered with each of the dictionaries.
//
// parseFile() invokes this after parsing all <name> records.

void
ParserImpl::registerAllNamesWithBuilder()
{
    // Register with the builder only the names in the dictionaries, not
    // the unregistered names in unregPropNames and unregTextStrings.
    //
    // Unregistered PropNames are those created for PROPERTY records
    // that contain a propname-string rather than a reference-number.
    // These names do not correspond to a PROPNAME record.  Similarly
    // unregistered TextStrings are those created for TEXT records that
    // have a text-string.  They don't correspond to a TEXTSTRING
    // record.

    CellNameDict::const_iterator  cellNameIter = cellNameDict.begin();
    CellNameDict::const_iterator  cellNameEnd  = cellNameDict.end();
    for ( ;  cellNameIter != cellNameEnd;  ++cellNameIter)
        builder->registerCellName(*cellNameIter);

    TextStringDict::const_iterator  textStringIter = textStringDict.begin();
    TextStringDict::const_iterator  textStringEnd  = textStringDict.end();
    for ( ;  textStringIter != textStringEnd;  ++textStringIter)
        builder->registerTextString(*textStringIter);

    PropNameDict::const_iterator  propNameIter = propNameDict.begin();
    PropNameDict::const_iterator  propNameEnd  = propNameDict.end();
    for ( ;  propNameIter != propNameEnd;  ++propNameIter)
        builder->registerPropName(*propNameIter);

    PropStringDict::const_iterator  propStringIter = propStringDict.begin();
    PropStringDict::const_iterator  propStringEnd  = propStringDict.end();
    for ( ;  propStringIter != propStringEnd;  ++propStringIter)
        builder->registerPropString(*propStringIter);

    LayerNameDict::const_iterator  layerNameIter = layerNameDict.begin();
    LayerNameDict::const_iterator  layerNameEnd  = layerNameDict.end();
    for ( ;  layerNameIter != layerNameEnd;  ++layerNameIter)
        builder->registerLayerName(*layerNameIter);

    XNameDict::const_iterator  xnameIter = xnameDict.begin();
    XNameDict::const_iterator  xnameEnd  = xnameDict.end();
    for ( ;  xnameIter != xnameEnd;  ++xnameIter)
        builder->registerXName(*xnameIter);
}



//----------------------------------------------------------------------
//                              Name Tables
//----------------------------------------------------------------------

// The functions in this section are invoked only when all the name
// tables we care about are strict.  A name table is a set of contiguous
// name records of the appropriate type, each of which may be followed
// by PROPERTY records.  The functions are similar.  Each sets the
// ending offset of the table (if it is non-empty) so that parseFile()
// can check for stray records during the second phase of parsing.
//
// XXX: These functions do not complain if a name-table offset is
// non-zero but there are no name records of the corresponding type at
// the offset given.  One test suite asserts that this makes the file
// invalid, but paragraph 13.10 says that diagnostics are optional for
// strictness errors if they do not affect the parser.


void
ParserImpl::parseCellNameTable()
{
    // 13.6
    // A byte-offset of 0 indicates the absence of that particular table.

    if (cellNameDict.getStartOffset() == 0)
        return;
    seekTo(cellNameDict.getStartOffset());

    for (;;) {
        OasisRecord*  orecp = readNextRecord();
        if (orecp->recID == RID_CELLNAME
            ||  orecp->recID == RID_CELLNAME_R)
            parseCellName(static_cast<NameRecord*>(orecp));
        else {
            cellNameDict.setEndPosition(orecp->recPos);
            unreadLastRecord();
            break;
        }
    }
}



void
ParserImpl::parseTextStringTable()
{
    if (textStringDict.getStartOffset() == 0)
        return;
    seekTo(textStringDict.getStartOffset());

    for (;;) {
        OasisRecord*  orecp = readNextRecord();
        if (orecp->recID == RID_TEXTSTRING
                ||  orecp->recID == RID_TEXTSTRING_R)
            parseTextString(static_cast<NameRecord*>(orecp));
        else {
            textStringDict.setEndPosition(orecp->recPos);
            unreadLastRecord();
            break;
        }
    }
}



void
ParserImpl::parsePropNameTable()
{
    if (propNameDict.getStartOffset() == 0)
        return;
    seekTo(propNameDict.getStartOffset());

    for (;;) {
        OasisRecord*  orecp = readNextRecord();
        if (orecp->recID == RID_PROPNAME
                ||  orecp->recID == RID_PROPNAME_R)
            parsePropName(static_cast<NameRecord*>(orecp));
        else {
            propNameDict.setEndPosition(orecp->recPos);
            unreadLastRecord();
            break;
        }
    }
}



void
ParserImpl::parsePropStringTable()
{
    if (propStringDict.getStartOffset() == 0)
        return;
    seekTo(propStringDict.getStartOffset());

    for (;;) {
        OasisRecord*  orecp = readNextRecord();
        if (orecp->recID == RID_PROPSTRING
                ||  orecp->recID == RID_PROPSTRING_R)
            parsePropString(static_cast<NameRecord*>(orecp));
        else {
            propStringDict.setEndPosition(orecp->recPos);
            unreadLastRecord();
            break;
        }
    }
}



void
ParserImpl::parseLayerNameTable()
{
    if (layerNameDict.getStartOffset() == 0)
        return;
    seekTo(layerNameDict.getStartOffset());

    for (;;) {
        OasisRecord*  orecp = readNextRecord();
        if (orecp->recID == RID_LAYERNAME_GEOMETRY
                ||  orecp->recID == RID_LAYERNAME_TEXT)
            parseLayerName(static_cast<LayerNameRecord*>(orecp));
        else {
            layerNameDict.setEndPosition(orecp->recPos);
            unreadLastRecord();
            break;
        }
    }
}



void
ParserImpl::parseXNameTable()
{
    if (xnameDict.getStartOffset() == 0)
        return;
    seekTo(xnameDict.getStartOffset());

    for (;;) {
        OasisRecord*  orecp = readNextRecord();
        if (orecp->recID == RID_XNAME
                ||  orecp->recID == RID_XNAME_R)
            parseXName(static_cast<XNameRecord*>(orecp));
        else {
            xnameDict.setEndPosition(orecp->recPos);
            unreadLastRecord();
            break;
        }
    }
}



//----------------------------------------------------------------------
//                              Names
//----------------------------------------------------------------------

// Functions to parse <name> records and associated PROPERTY records.


void
ParserImpl::parseCellName (NameRecord* recp)
{
    // Section 15:  CELLNAME record
    // `3' cellname-string
    // `4' cellname-string reference-number

    assert (recp->recID == RID_CELLNAME
            ||  recp->recID == RID_CELLNAME_R);
    verifyExclusiveRecords(recp->recID, RID_CELLNAME, RID_CELLNAME_R);
    modvars.reset();    // 10.1

    // When there are multiple CELLNAME records for a single cell name,
    // we need to distinguish in parseStdCellNameProperties() the
    // properties from different CELLNAMEs.  So if a CellName already
    // has properties, add a dummy property to act as a separator.  We
    // will remove it later in parseStdCellNameProperties().
    //
    // This check is needed only when the refnum is explicit, because
    // only then can different CELLNAME records refer to the same name.

    CellName*  cellName;
    verifyStringIsName(recp->name);
    if (recp->recID == RID_CELLNAME) {
        if ((cellName = cellNameDict.add(recp->name)) == Null)
            abortParser("duplicate name '%s'", recp->name.c_str());
    } else {
        if ((cellName = cellNameDict.add(recp->name, recp->refnum)) == Null)
            abortParser("duplicate name '%s' or reference-number %lu",
                        recp->name.c_str(), recp->refnum);
        if (! cellName->getPropertyList().empty()) {
            auto_ptr<Property>  sep(new Property(separatorPropName, false));
            sep->addValue(PV_UnsignedInteger, 0ull);    // dummy
            cellName->addProperty(sep.get());
            sep.release();
        }
    }
    parseNameProperties(cellName);
}



void
ParserImpl::parseTextString (NameRecord* recp)
{
    // Section 16:  TEXTSTRING record
    // `5' text-string
    // `6' text-string reference-number

    assert (recp->recID == RID_TEXTSTRING
            ||  recp->recID == RID_TEXTSTRING_R);
    verifyExclusiveRecords(recp->recID, RID_TEXTSTRING, RID_TEXTSTRING_R);
    modvars.reset();    // 10.1

    TextString*  textString;
    verifyStringIsAscii(recp->name);
    if (recp->recID == RID_TEXTSTRING)
        textString = textStringDict.add(recp->name);
    else
        textString = textStringDict.add(recp->name, recp->refnum);

    // When parserOptions.strictConformance is false we allow control
    // chars in ascii-strings.  So if we need to print an error message
    // we must first construct a printable representation of the
    // text-string.

    if (textString == Null) {
        char  buf[256];
        MakePrintableString(recp->name.data(), recp->name.size(),
                            buf, sizeof(buf));
        if (recp->recID == RID_TEXTSTRING)
            abortParser("duplicate text string '%s'", buf);
        else
            abortParser("duplicate text string '%s' or reference-number %lu",
                        buf, recp->refnum);
    }
    parseNameProperties(textString);
}



void
ParserImpl::parsePropName (NameRecord* recp)
{
    // Section 17:  PROPNAME record
    // `7' propname-string
    // `8' propname-string reference-number

    assert (recp->recID == RID_PROPNAME
            ||  recp->recID == RID_PROPNAME_R);
    verifyExclusiveRecords(recp->recID, RID_PROPNAME, RID_PROPNAME_R);
    modvars.reset();    // 10.1

    PropName*  propName;
    verifyStringIsName(recp->name);
    if (recp->recID == RID_PROPNAME) {
        if ((propName = propNameDict.add(recp->name)) == Null)
            abortParser("duplicate name '%s'", recp->name.c_str());
    } else {
        if ((propName = propNameDict.add(recp->name, recp->refnum)) == Null)
            abortParser("duplicate name '%s' or reference-number %lu",
                        recp->name.c_str(), recp->refnum);
    }
    parseNameProperties(propName);
}



void
ParserImpl::parsePropString (NameRecord* recp)
{
    // Section 18:  PROPSTRING record
    // `9'  prop-string
    // `10' prop-string reference-number

    assert (recp->recID == RID_PROPSTRING
            ||  recp->recID == RID_PROPSTRING_R);
    verifyExclusiveRecords(recp->recID, RID_PROPSTRING, RID_PROPSTRING_R);
    modvars.reset();    // 10.1

    PropString*  propString;
    if (recp->recID == RID_PROPSTRING) {
        propString = propStringDict.add(recp->name);
        assert (propString != Null);
    } else {
        if ((propString = propStringDict.add(recp->name,recp->refnum)) == Null)
            abortParser("duplicate reference-number %lu", recp->refnum);
    }
    parseNameProperties(propString);
}



void
ParserImpl::parseLayerName (LayerNameRecord* recp)
{
    // Section 19:  LAYERNAME record
    // `11' layername-string layer-interval datatype-interval
    // `12' layername-string textlayer-interval texttype-interval

    assert (recp->recID == RID_LAYERNAME_GEOMETRY
            || recp->recID == RID_LAYERNAME_TEXT);
    assert (parserOptions.wantLayerName);
    modvars.reset();    // 10.1

    LayerName::IntervalType  ivalType;
    LayerName*  layerName;

    verifyStringIsName(recp->name);
    ivalType = (recp->recID == RID_LAYERNAME_GEOMETRY)
                    ? LayerName::GeometryInterval
                    : LayerName::TextInterval;
    Interval  layers = parseInterval(recp->layers);
    Interval  types  = parseInterval(recp->types);

    layerName = layerNameDict.add(recp->name, ivalType, layers, types);
    parseNameProperties(layerName);
}



// parseInterval -- convert raw LAYERNAME interval into internal form
//   rawint     raw interval as specified in file, with type, bound_a, bound_b.

Interval
ParserImpl::parseInterval (const LayerNameRecord::RawInterval& rawint)
{
    assert (rawint.type <= 4);   // OasisRecordReader has already checked

    // Note that type-4 intervals may be empty (bound_a > bound_b).
    // The spec does not forbid them and we don't care.

    switch (rawint.type) {
        case 0:  return Interval(0);                    // 0..infinity
        case 1:  return Interval(0, rawint.bound_a);
        case 2:  return Interval(rawint.bound_a);       // bound_a..infinity
        case 3:  return Interval(rawint.bound_a, rawint.bound_a);
        default: return Interval(rawint.bound_a, rawint.bound_b);
    }
}



void
ParserImpl::parseXName (XNameRecord* recp)
{
    // Section 32:  XNAME record
    // `30' xname-attribute xname-string
    // `31' xname-attribute xname-string reference-number

    assert (recp->recID == RID_XNAME  ||  recp->recID == RID_XNAME_R);
    verifyExclusiveRecords(recp->recID, RID_XNAME, RID_XNAME_R);
    modvars.reset();    // 10.1

    XName*  xname;
    if (recp->recID == RID_XNAME)
        xname = xnameDict.add(recp->name);
    else {
        // The code here is different from the corresponding code in
        // parseCellName() etc. because we need to check for conflicting
        // attributes.
        //
        xname = xnameDict.lookupRefnum(recp->refnum);
        if (xname != Null  &&  xname->getName() != recp->name)
            abortParser("reference-number %lu conflicts with earlier "
                        "XNAME record", recp->refnum);          // 32.4

        // XXX: The spec does not say what to do if two XNAME records
        // have the same name and reference-number but different
        // attributes.  We replace the old attribute with a warning.

        if (xname != Null  &&  xname->getAttribute() != recp->attribute) {
            warn("XNAME %lu %s %lu replaces previous XNAME record with "
                 "attribute %lu",
                 recp->attribute, recp->name.c_str(), recp->refnum,
                 xname->getAttribute() );
        }
        if (xname == Null)
            xname = xnameDict.add(recp->name, recp->refnum);
    }
    xname->setAttribute(recp->attribute);
    parseNameProperties(xname);
}



//----------------------------------------------------------------------
//                            CELL Records
//----------------------------------------------------------------------

// getAllCellOffsets -- find the offsets of all CELL records in the file
// Scans the whole file looking for CELL records and notes their offsets.
// The public parseCell() calls this when it is given a cell whose
// offset it does not know.

void
ParserImpl::getAllCellOffsets()
{
    // If we have already scanned the whole file, there is no need to do
    // it again.  Note that parseFile() and parseAllNamesSequentially()
    // also set haveAllCellOffsets.

    if (haveAllCellOffsets)
        return;

    seekTo(StartRecordOffset);

    OasisRecord*  orecp;
    while (orecp = readNextRecord(), orecp->recID != RID_END) {
        if (orecp->recID == RID_CELL_REF  ||  orecp->recID == RID_CELL_NAMED)
            parseCellRecord(static_cast<CellRecord*>(orecp));
    }

    haveAllCellOffsets = true;
}



// parseCell -- parse all records in cell and invoke builder's callbacks.
//   recp       the CELL record that begins the cell

void
ParserImpl::parseCell (CellRecord* recp)
{
    assert (recp->recID == RID_CELL_REF  ||  recp->recID == RID_CELL_NAMED);

    // Parse the CELL record and locate the CellName object for that,
    // creating it if needed.

    CellName*  cellName = parseCellRecord(recp);
    modvars.reset();            // 10.1

    // Invoke builder callbacks for the cell and its properties.  The
    // cell properties must immediately follow the CELL record (31.8).

    builder->beginCell(cellName);
    parsePropertiesForBuilder(PC_Cell);

    // 6.2
    // <cell>     ::= CELL { CBLOCK | PAD | PROPERTY |
    //                       XYRELATIVE | XYABSOLUTE | <element> }*
    // <element>  ::= <geometry> | PLACEMENT | TEXT | XELEMENT
    // <geometry> ::= RECTANGLE | POLYGON | PATH | TRAPEZOID |
    //                CTRAPEZOID | CIRCLE | XGEOMETRY

    // The parsing function for each element also parses the property
    // records that follow the element record.

    for (;;) {
        OasisRecord*  orecp = readNextRecord();
        switch (orecp->recID) {
            case RID_XYABSOLUTE:  xyRelative(false);    break;
            case RID_XYRELATIVE:  xyRelative(true);     break;

            case RID_PLACEMENT:
            case RID_PLACEMENT_TRANSFORM:
                parsePlacement(cellName, static_cast<PlacementRecord*>(orecp));
                break;

            case RID_TEXT:
                parseText(static_cast<TextRecord*>(orecp));
                break;

            case RID_RECTANGLE:
                parseRectangle(static_cast<RectangleRecord*>(orecp));
                break;

            case RID_POLYGON:
                parsePolygon(static_cast<PolygonRecord*>(orecp));
                break;

            case RID_PATH:
                parsePath(static_cast<PathRecord*>(orecp));
                break;

            case RID_TRAPEZOID:
            case RID_TRAPEZOID_A:
            case RID_TRAPEZOID_B:
                parseTrapezoid(static_cast<TrapezoidRecord*>(orecp));
                break;

            case RID_CTRAPEZOID:
                parseCTrapezoid(static_cast<CTrapezoidRecord*>(orecp));
                break;

            case RID_CIRCLE:
                parseCircle(static_cast<CircleRecord*>(orecp));
                break;

            case RID_XELEMENT:
                parseXElement(static_cast<XElementRecord*>(orecp));
                break;

            case RID_XGEOMETRY:
                parseXGeometry(static_cast<XGeometryRecord*>(orecp));
                break;

            default:
                // The cell ends when we see a non-element record.
                unreadLastRecord();
                goto END_LOOP;
        }
    }
  END_LOOP:

    builder->endCell();
}



// parseCellRecord -- parse CELL record and remember its offset.
// This may be called either in the first phase (name records only) or
// in the second phase (all other records).  In the first phase,
// parseAllNamesSequentially() parses the CELL records (to collect their
// offsets) in addition to the <name> records.

CellName*
ParserImpl::parseCellRecord (CellRecord* recp)
{
    CellName*  cellName;

    // Section 20:  CELL Record
    // `13' reference-number
    // `14' cellname-string

    // 35.4: CELL records may not be stored within a compressed record.
    if (recp->recPos.inCblock())
        abortParser("CELL record not allowed inside CBLOCK");

    // Look up or create the CellName for this refnum/name.  If
    // allNamesParsed is false, this function is being called during the
    // names-only first phase by parseAllNamesSequentially().  Because
    // not all <name> records may have been parsed, we allow undefined
    // refnums, and let cellNameDict.lookupRefnum() create a new
    // CellName.  If allNamesParsed is true, this is being called during
    // the second phase.  Then the refnum must already exist in the
    // dictionary.

    if (recp->recID == RID_CELL_REF) {
        cellName = cellNameDict.lookupRefnum(recp->refnum, !allNamesParsed);
        if (cellName == Null)
            abortParser("reference-number %lu not defined", recp->refnum);
    } else {
        if (parserOptions.strictConformance && cellNameDict.isStrict())
            abortParser("cellname-string forbidden in strict mode");  // 13.10
        verifyStringIsName(recp->name);
        cellName = cellNameDict.lookupName(recp->name, true);
    }

    // 20.4  If the cell has already been defined elsewhere, complain
    // about a duplicate name.  It is not enough to check
    // cell->isDefined() alone because the application may parse a cell
    // several times.  We must also look at the offset of earlier
    // definition.

    Cell*  cell = cellDict.lookup(cellName, true);
    if (cell->isDefined()  &&  cell->getOffset() != recp->recPos.fileOffset) {
        if (recp->recID == RID_CELL_REF)
            abortParser("duplicate definition of cell %lu", recp->refnum);
        else
            abortParser("duplicate definition of cell %s", recp->name.c_str());
    }

    // This also notes the cell as being defined.
    cell->setOffsetFromCell(recp->recPos.fileOffset);
    return cellName;
}



// parseStdCellNameProperties -- check S_CELL_OFFSET and S_BOUNDING_BOX.
// This function is called at the end of the first phase of the parse,
// after all <name> records and their properties have been parsed.  Here
// we examine all CellName objects for the S_CELL_OFFSET property, and
// save the offset in the cell directory.  We also verify that each
// S_CELL_OFFSET and S_BOUNDING_BOX property occurs at most once for
// each CELLNAME record, as required by paragraph 15.5.
//
// We cannot examine each CELLNAME's property list immediately after
// parsing it because of forward references.  The PROPERTY record may
// use a reference-number for the property name, and the PROPNAME record
// for S_CELL_OFFSET may be at the end of the file.  Only after parsing
// all names are we guaranteed to have the property names available to
// compare with S_CELL_OFFSET.
//
// We do not check the values of S_BOUNDING_BOX for validity.  In
// general we check only the values of the standard properties that we
// use here, because there is a good chance that some tool will generate
// wrong values.  Then customers would ask for the check to be disabled.
//
// Precondition:
//   All CellName objects have names
//   (i.e. checkAllNamesDefined() was called earlier).

void
ParserImpl::parseStdCellNameProperties()
{
    // Paragraph 15.5 forbids more than one S_CELL_OFFSET or
    // S_BOUNDING_BOX after a given CELLNAME, but there may be more than
    // one CELLNAME with a given name.  We merge the properties of all
    // CELLNAME records for a name into one list, with a dummy
    // non-standard property separating the properties of different
    // CELLNAME records (see parseCellName()).
    //
    // To check for duplicates, keep two flags, hasOffsetProp and
    // hasBBoxProp, to record whether S_CELL_OFFSET and S_BOUNDING_BOX
    // appeared.  Reset these flags when the special separator property
    // is seen.  At the end, remove all separator properties if any
    // appeared.
    //
    // Also collect the offset from the S_CELL_OFFSET property and store
    // it in the cell directory.  If the property appears more than once
    // (in different CELLNAME records), do not complain even if the
    // values differ; simply select an arbitrary one.  Usually the
    // application will process the entire file, so we will not use the
    // offset.

    string  s_cell_offset(S_CELL_OFFSET);
    string  s_bounding_box(S_BOUNDING_BOX);

    CellNameDict::const_iterator  nameIter = cellNameDict.begin();
    CellNameDict::const_iterator  nameEnd  = cellNameDict.end();
    for ( ;  nameIter != nameEnd;  ++nameIter) {
        CellName*  cellName = *nameIter;
        const char*  cname = cellName->getName().c_str();

        bool  hasSeparator = false;     // prop list contains separator property
        bool  hasOffsetProp = false;    // S_CELL_OFFSET present
        bool  hasBBoxProp = false;      // S_BOUNDING_BOX present

        const PropertyList&  plist = cellName->getPropertyList();
        PropertyList::const_iterator  propIter = plist.begin();
        PropertyList::const_iterator  propEnd  = plist.end();
        for ( ;  propIter != propEnd;  ++propIter) {
            Property*  prop = *propIter;
            if (! prop->isStandard()) {
                if (prop->getName() == separatorPropName) {
                    hasSeparator = true;
                    hasOffsetProp = false;
                    hasBBoxProp = false;
                }
            }
            else if (prop->getName()->getName() == s_cell_offset) {
                if (hasOffsetProp) {
                    abortParser("CELLNAME '%s' has duplicate "
                                "S_CELL_OFFSET property", cname);
                }
                hasOffsetProp = true;
                parseCellOffsetProperty(cellName, prop);
            }
            else if (prop->getName()->getName() == s_bounding_box) {
                if (hasBBoxProp) {
                    abortParser("CELLNAME '%s' has duplicate "
                                "S_BOUNDING_BOX property", cname);
                }
                hasBBoxProp = true;
            }
        }
        if (hasSeparator)
            cellName->removeProperties(separatorPropName, false);
    }
}



// parseCellOffsetProperty -- get and validate value of S_CELL_OFFSET property
//   cellName   cellName that owns the property
//   prop       a standard property with propname S_CELL_OFFSET

void
ParserImpl::parseCellOffsetProperty (const CellName* cellName,
                                     const Property* prop)
{
    // Verify that the property has exactly one value, the value is an
    // unsigned-integer, and the value is valid.  Simply ignore invalid
    // properties if not strictly conforming to the spec.  Methods that
    // need the offset will then call getAllCellOffsets().

    const char*  cname = cellName->getName().c_str();
    if (prop->numValues() != 1) {
        if (parserOptions.strictConformance) {
            abortParser("S_CELL_OFFSET property of '%s' has %lu values "
                        "instead of 1",
                        cname, static_cast<Ulong>(prop->numValues()) );
        }
        return;
    }
    const PropValue*  propval = prop->getValue(0);
    if (propval->getType() != PV_UnsignedInteger) {
        if (parserOptions.strictConformance) {
            abortParser("S_CELL_OFFSET property of '%s' has wrong value type: "
                        "%d instead of %d",
                        cname, propval->getType(), PV_UnsignedInteger);
        }
        return;
    }
    Ullong  offset = propval->getUnsignedIntegerValue();
    if (offset >= fileSize) {
        if (parserOptions.strictConformance) {
            abortParser("S_CELL_OFFSET property of '%s' has value %llu, "
                        "which is greater than the file size",
                        cname, offset);
        }
        return;
    }

    // Get the Cell object for the cell, constructing it if needed,
    // and store the offset in that.

    Cell*  cell = cellDict.lookup(cellName, true);
    cell->setOffsetFromProperty(offset);
}



//----------------------------------------------------------------------
//                              Elements
//----------------------------------------------------------------------

// Each function in this section parses an element record and the
// PROPERTY records that follow it.  After parsing the element record
// FOO the function invokes the builder->addFoo().  After parsing each
// PROPERTY record it passes the Property object constructed to
// builder->addElementProperty() and then deletes the Property object.
// Then it calls builder->endElement().


// parsePlacement -- parse a PLACEMENT record
// The parentCell arg is the CellName for the cell that contains this
// record.  We need it to check for recursive references.

void
ParserImpl::parsePlacement (const CellName* parentCell,
                            const PlacementRecord* recp)
{
    // Section 22:  PLACEMENT record
    // `17' placement-info-byte [reference-number | cellname-string]
    //      [x] [y] [repetition]
    // placement-info-byte ::= CNXYRAAF
    //
    // `18' placement-info-byte [reference-number | cellname-string]
    //      [magnification] [angle] [x] [y] [repetition]
    // placement-info-byte ::= CNXYRMAF

    assert (recp->recID == RID_PLACEMENT
            ||  recp->recID == RID_PLACEMENT_TRANSFORM);
    using namespace PlacementInfoByte;

    int  infoByte = recp->infoByte;
    CellName*  cellName = getPlacementCell(infoByte & CellExplicitBit,
                                           infoByte & RefnumBit,
                                           recp->name, recp->refnum);
    // 22.10
    if (cellName == parentCell)
        abortParser("recursive reference to containing cell");

    // Check the magnification and angle.  For type-17 records there is
    // no magnification and the angle is encoded in the infobyte.

    Oreal   mag, angle;

    if (recp->recID == RID_PLACEMENT) {
        mag = 1;
        angle = GetAngle(infoByte);
    } else {
        mag   = (infoByte & MagBit) ? recp->mag : Oreal(1);
        angle = (infoByte & AngleBit) ? recp->angle : Oreal(0);
    }
    double  magValue = mag.getValue();
    if (!isfinite(magValue)  ||  magValue <= 0.0)
        abortParser("invalid magnification %.15g", magValue);

    double  angleValue = angle.getValue();
    if (!isfinite(angleValue))
        abortParser("invalid angle %.15g", angleValue);

    long  x = getPlacementX(infoByte & XBit, recp->x);
    long  y = getPlacementY(infoByte & YBit, recp->y);
    const Repetition*  rep = getRepetition(infoByte & RepBit, recp->rawrep);

    builder->beginPlacement(cellName, x, y, mag, angle, (infoByte & FlipBit),
                            rep);
    parsePropertiesForBuilder(PC_Element);
    builder->endElement();
}



void
ParserImpl::parseText (const TextRecord* recp)
{
    // Section 24:  TEXT record
    // `19' text-info-byte [reference-number | text-string]
    //      [textlayer-number] [texttype-number] [x] [y] [repetition]
    // text-info-byte ::= 0CNXYRTL

    assert (recp->recID == RID_TEXT);
    using namespace TextInfoByte;

    int  infoByte = recp->infoByte;
    checkInfoByte(infoByte, ValidInfoBits);

    // If the application does not want TEXT records, process the
    // repetition to set the modal variable.  Ignore the other fields;
    // their modal variables need not be set because they are specific
    // to TEXT records.  (The textString field cannot be parsed anyway
    // because TEXTSTRING records are ignored.)  Then skip any following
    // PROPERTY records.

    if (not parserOptions.wantText) {
        (void) getRepetition(infoByte & RepBit, recp->rawrep);
        skipPropertyRecords();
        return;
    }

    TextString*  textString = getTextString (infoByte & TextExplicitBit,
                                             infoByte & RefnumBit,
                                             recp->text, recp->refnum);

    Ulong  textlayer = getTextlayer (infoByte & TextlayerBit, recp->textlayer);
    Ulong  texttype  = getTexttype  (infoByte & TexttypeBit,  recp->texttype);
    long   x         = getTextX     (infoByte & XBit,         recp->x);
    long   y         = getTextY     (infoByte & YBit,         recp->y);
    const Repetition*  rep = getRepetition (infoByte & RepBit, recp->rawrep);

    builder->beginText(textlayer, texttype, x, y, textString, rep);
    parsePropertiesForBuilder(PC_Element);
    builder->endElement();
}



void
ParserImpl::parseRectangle (const RectangleRecord* recp)
{
    // Section 25:  RECTANGLE record
    // `20' rectangle-info-byte [layer-number] [datatype-number]
    //      [width] [height] [x] [y] [repetition]
    // rectangle-info-byte ::= SWHXYRDL
    // If S = 1, the rectangle is a square, and H must be 0.

    assert (recp->recID == RID_RECTANGLE);
    using namespace RectangleInfoByte;

    int  infoByte = recp->infoByte;

    // 25.7:  "When S=1, H=1 should be treated as a fatal error."
    if ((infoByte & (SquareBit|HeightBit)) == (SquareBit|HeightBit))
        abortParser("S and H bits both set in info-byte");

    Ulong  layer    = getLayer    (infoByte & LayerBit,    recp->layer);
    Ulong  datatype = getDatatype (infoByte & DatatypeBit, recp->datatype);

    // 25.6: "When S=1, both geometry-w and geometry-h are set to the
    // rectangle's width."
    long  width    = getGeometryWidth (infoByte & WidthBit, recp->width);
    if (infoByte & SquareBit)
        modvars.setGeometryHeight(width);

    long  height   = getGeometryHeight (infoByte & HeightBit, recp->height);
    long  x        = getGeometryX      (infoByte & XBit,      recp->x);
    long  y        = getGeometryY      (infoByte & YBit,      recp->y);
    const Repetition* rep = getRepetition (infoByte & RepBit, recp->rawrep);

    builder->beginRectangle(layer, datatype, x, y, width, height, rep);
    parsePropertiesForBuilder(PC_Element);
    builder->endElement();
}



void
ParserImpl::parsePolygon (const PolygonRecord* recp)
{
    // Section 26:  POLYGON Record
    // `21' polygon-info-byte [layer-number] [datatype-number]
    //      [point-list] [x] [y] [repetition]
    // polygon-info-byte ::= 00PXYRDL

    assert (recp->recID == RID_POLYGON);
    using namespace PolygonInfoByte;

    int  infoByte = recp->infoByte;
    checkInfoByte(infoByte, ValidInfoBits);

    Ulong  layer    = getLayer     (infoByte & LayerBit,    recp->layer);
    Ulong  datatype = getDatatype  (infoByte & DatatypeBit, recp->datatype);

    const PointList&  ptlist(getPolygonPoints(infoByte & PointListBit,
                                              recp->ptlist));

    long  x         = getGeometryX (infoByte & XBit,        recp->x);
    long  y         = getGeometryY (infoByte & YBit,        recp->y);
    const Repetition* rep = getRepetition (infoByte & RepBit, recp->rawrep);

    builder->beginPolygon(layer, datatype, x, y, ptlist, rep);
    parsePropertiesForBuilder(PC_Element);
    builder->endElement();
}



void
ParserImpl::parsePath (const PathRecord* recp)
{
    // Section 27:  PATH record
    // `22' path-info-byte [layer-number] [datatype-number] [half-width]
    //      [ extension-scheme [start-extension] [end-extension] ]
    //      [point-list] [x] [y] [repetition]
    // path-info-byte ::= EWPXYRDL

    assert (recp->recID == RID_PATH);
    using namespace PathInfoByte;

    int  infoByte = recp->infoByte;
    Ulong layer    = getLayer    (infoByte & LayerBit,    recp->layer);
    Ulong datatype = getDatatype (infoByte & DatatypeBit, recp->datatype);
    long  halfwidth = getPathHalfwidth (infoByte & HalfwidthBit,
                                        recp->halfwidth);

    // If the E bit is set, look at the extension scheme.  This has
    // the format 0000SSEE.  The SS bits decide the starting extension,
    // including whether recp->startExtn is valid.  The EE bits decide
    // the end extension.

    Ulong extnScheme = (infoByte & ExtensionBit) ? recp->extnScheme : 0;
    if (parserOptions.strictConformance && ! ExtensionSchemeIsValid(extnScheme))
        abortParser("invalid extension-scheme %#lx", extnScheme);

    long  startExtn = getStartExtension(GetStartScheme(extnScheme),
                                        halfwidth, recp->startExtn);
    long  endExtn   = getEndExtension(GetEndScheme(extnScheme),
                                      halfwidth, recp->endExtn);

    const PointList&  ptlist(getPathPoints(infoByte & PointListBit,
                                           recp->ptlist));

    long  x = getGeometryX (infoByte & XBit, recp->x);
    long  y = getGeometryY (infoByte & YBit, recp->y);
    const Repetition* rep = getRepetition (infoByte & RepBit, recp->rawrep);

    builder->beginPath(layer, datatype, x, y, halfwidth,
                       startExtn, endExtn, ptlist, rep);
    parsePropertiesForBuilder(PC_Element);
    builder->endElement();
}



void
ParserImpl::parseTrapezoid (const TrapezoidRecord* recp)
{
    // Section 28:  TRAPEZOID record
    //
    // `23' trap-info-byte [layer-number] [datatype-number]
    //      [width] [height] delta-a delta-b [x] [y] [repetition]
    //
    // `24' trap-info-byte [layer-number] [datatype-number]
    //      [width] [height] delta-a         [x] [y] [repetition]
    //
    // `25' trap-info-byte [layer-number] [datatype-number]
    //      [width] [height]         delta-b [x] [y] [repetition]
    //
    // trap-info-byte ::= OWHXYRDL

    assert (recp->recID == RID_TRAPEZOID
            ||  recp->recID == RID_TRAPEZOID_A
            ||  recp->recID == RID_TRAPEZOID_B);
    using namespace TrapezoidInfoByte;

    int  infoByte = recp->infoByte;
    Ulong layer    = getLayer        (infoByte & LayerBit,    recp->layer);
    Ulong datatype = getDatatype     (infoByte & DatatypeBit, recp->datatype);
    long width     = getGeometryWidth  (infoByte & WidthBit,  recp->width);
    long height    = getGeometryHeight (infoByte & HeightBit, recp->height);

    long  delta_a  = (recp->recID == RID_TRAPEZOID_B ? 0 : recp->delta_a);
    long  delta_b  = (recp->recID == RID_TRAPEZOID_A ? 0 : recp->delta_b);

    long  x = getGeometryX (infoByte & XBit, recp->x);
    long  y = getGeometryY (infoByte & YBit, recp->y);
    const Repetition* rep = getRepetition (infoByte & RepBit, recp->rawrep);

    Trapezoid::Orientation orient = (infoByte & VerticalBit)
                                    ? Trapezoid::Vertical
                                    : Trapezoid::Horizontal;

    try {
        Trapezoid  trap(orient, width, height, delta_a, delta_b);
        builder->beginTrapezoid(layer, datatype, x, y, trap, rep);
    } catch (const BadTrapezoidError&) {
        abortParser("invalid trapezoid");
    }
    parsePropertiesForBuilder(PC_Element);
    builder->endElement();
}



void
ParserImpl::parseCTrapezoid (const CTrapezoidRecord* recp)
{
    // Section 29:  CTRAPEZOID record
    // `26' ctrapezoid-info-byte [layer-number] [datatype-number]
    //      [ctrapezoid-type] [width] [height] [x] [y] [repetition]
    // ctrapezoid-info-byte ::= TWHXYRDL

    assert (recp->recID == RID_CTRAPEZOID);
    using namespace CTrapezoidInfoByte;

    int  infoByte = recp->infoByte;
    Ulong layer     = getLayer    (infoByte & LayerBit,    recp->layer);
    Ulong datatype  = getDatatype (infoByte & DatatypeBit, recp->datatype);
    Uint  ctrapType = getCTrapezoidType (infoByte & TrapTypeBit,
                                         recp->ctrapType);

    // 29.6: "For types 16-19, 22-23, and 25, height is not used, and H
    // must be 0.  For types 20-21, width is not used and W must be 0."
    //
    // Because getGeometryWidth() might try to access the modal
    // variable geometry-w when it is undefined, we cannot blindly
    // invoke it and then ignore the return value if we don't want it.
    // Similarly for getGeometryHeight().

    long  width = 0, height = 0;
    if (Trapezoid::needWidth(ctrapType))
        width = getGeometryWidth(infoByte & WidthBit, recp->width);
    else if (infoByte & WidthBit)
        abortParser("W bit set in info-byte for ctrapezoid-type %u",ctrapType);

    if (Trapezoid::needHeight(ctrapType))
        height = getGeometryHeight(infoByte & HeightBit, recp->height);
    else if (infoByte & HeightBit)
        abortParser("H bit set in info-byte for ctrapezoid-type %u",ctrapType);

    long  x = getGeometryX (infoByte & XBit, recp->x);
    long  y = getGeometryY (infoByte & YBit, recp->y);
    const Repetition*  rep = getRepetition (infoByte & RepBit, recp->rawrep);

    // 29.7: "for the forms where only one of width or height is used,
    // (types 16-23 and 25), modal variables geometry-w or geometry-h
    // are both updated to match the specified dimension."
    //
    // It is simpler to set both modal variables unconditionally.
    // It may be redundant for most cases, but it doesn't hurt.

    try {
        Trapezoid  trap(ctrapType, width, height);
        modvars.setGeometryWidth(trap.getWidth());
        modvars.setGeometryHeight(trap.getHeight());
        builder->beginTrapezoid(layer, datatype, x, y, trap, rep);
    }
    catch (const BadTrapezoidError&) {
        abortParser("invalid ctrapezoid");
    }
    catch (const overflow_error& exc) {
        // XXX: This also catches overflow_error thrown by beginTrapezoid().
        abortParser("ctrapezoid too large: %s", exc.what());
    }
    parsePropertiesForBuilder(PC_Element);
    builder->endElement();
}



void
ParserImpl::parseCircle (const CircleRecord* recp)
{
    // Section 30:  CIRCLE record
    // `27' circle-info-byte [layer-number] [datatype-number]
    //      [radius] [x] [y] [repetition]
    // circle-info-byte ::= 00rXYRDL   (r is radius, R is repetition)

    assert (recp->recID == RID_CIRCLE);
    using namespace CircleInfoByte;

    int  infoByte = recp->infoByte;
    checkInfoByte(infoByte, ValidInfoBits);

    Ulong layer    = getLayer      (infoByte & LayerBit,    recp->layer);
    Ulong datatype = getDatatype   (infoByte & DatatypeBit, recp->datatype);
    Ulong radius   = getRadius     (infoByte & RadiusBit,   recp->radius);
    long  x        = getGeometryX  (infoByte & XBit,        recp->x);
    long  y        = getGeometryY  (infoByte & YBit,        recp->y);
    const Repetition* rep = getRepetition (infoByte & RepBit, recp->rawrep);

    builder->beginCircle(layer, datatype, x, y, radius, rep);
    parsePropertiesForBuilder(PC_Element);
    builder->endElement();
}



void
ParserImpl::parseXElement (const XElementRecord* recp)
{
    // Section 33:  XELEMENT record
    // `32' xelement-attribute xelement-string

    assert (recp->recID == RID_XELEMENT);

    if (parserOptions.wantExtensions) {
        builder->beginXElement(recp->attribute, recp->data);
        parsePropertiesForBuilder(PC_Element);
        builder->endElement();
    } else {
        skipPropertyRecords();
    }
}



void
ParserImpl::parseXGeometry (const XGeometryRecord* recp)
{
    // Section 34:  XGEOMETRY record
    // `33' xgeometry-info-byte xgeometry-attribute [layer-number]
    //      [datatype-number] xgeometry-string [x] [y] [repetition]
    // xgeometry-info-byte ::= 000XYRDL

    assert (recp->recID == RID_XGEOMETRY);
    using namespace XGeometryInfoByte;

    int  infoByte = recp->infoByte;
    checkInfoByte(infoByte, ValidInfoBits);

    // Process all the fields even if the application does not want
    // extension records, because the corresponding modal variables must
    // be set.

    Ulong  layer    = getLayer      (infoByte & LayerBit,     recp->layer);
    Ulong  datatype = getDatatype   (infoByte & DatatypeBit,  recp->datatype);
    long   x        = getGeometryX  (infoByte & XBit,         recp->x);
    long   y        = getGeometryY  (infoByte & YBit,         recp->y);
    const Repetition* rep = getRepetition (infoByte & RepBit, recp->rawrep);

    if (parserOptions.wantExtensions) {
        builder->beginXGeometry(layer, datatype, x, y,
                                recp->attribute, recp->data, rep);
        parsePropertiesForBuilder(PC_Element);
        builder->endElement();
    } else {
        skipPropertyRecords();
    }
}



//----------------------------------------------------------------------
//                              Properties
//----------------------------------------------------------------------

// getStdPropertyContexts -- get contexts in which a std property may appear
//   pname      property name
//
// Returns the bitwise-or of the PropertyContext enumerators for the
// valid contexts in which pname may appear, or 0 if pname is not the
// name of a standard property.

Uint
ParserImpl::getStdPropertyContexts (const string& pname)
{
    const StdPropertyContext*  spc = stdPropertyContexts;
    while (spc->pname != Null  &&  pname != spc->pname)
         ++spc;
    return (spc->validContexts);
}



// parseNameProperties -- parse PROPERTY records following <name> record.
//   oname      the OasisName object constructed for the <name> record
//
// The properties parsed are put on oname's property list.  We cannot
// pass them to the OasisBuilder immediately because there may be
// unresolved forward references to PROPNAME and PROPSTRING refnums.
//
// This method is invoked in the first phase of parsing, for names and
// their properties.

void
ParserImpl::parseNameProperties (OasisName* oname)
{
    OasisRecord*  orecp;
    while (orecp = readNextRecord(), IsPropertyRecord(orecp)) {
        PropertyRecord*  recp = static_cast<PropertyRecord*>(orecp);
        auto_ptr<Property>  aprop(parsePropertyRecord(recp));
        oname->addProperty(aprop.get());
        aprop.release();
    }
    unreadLastRecord();
}



// parsePropertiesForBuilder -- parse PROPERTY records and pass to builder
// This is for file, element, and cell properties.
//   ctxt         the context in which the properties are appearing --
//                PC_File, PC_Cell, or PC_Element.
//
// Each property is passed to the builder method immediately after being
// parsed, and deleted when the builder method returns.
//
// Compare this method with parseNameProperties() above, which just adds
// the properties to the OasisName's property list.  This method is
// invoked in the second phase of parsing, for everything except name
// records.  At this stage there is no danger of passing incomplete
// properties to the builder because all names are known.

void
ParserImpl::parsePropertiesForBuilder (enum PropertyContext ctxt)
{
    OasisRecord*  orecp;
    while (orecp = readNextRecord(), IsPropertyRecord(orecp)) {
        PropertyRecord*  recp = static_cast<PropertyRecord*>(orecp);
        auto_ptr<Property>  aprop(parsePropertyRecord(recp));
        Property*  prop = aprop.get();

        // If the property claims to be standard, verify that it is.
        // This is similar to the code in checkStdNameProperties().
        // The comment there explains why the check is disabled when
        // parserOptions.strictConformance is false.

        if (parserOptions.strictConformance && prop->isStandard()) {
            const string&  pname = prop->getName()->getName();
            Uint  validContexts = getStdPropertyContexts(pname);
            if (validContexts == 0) {
                abortParser("standard property with non-standard name '%s'",
                            pname.c_str());
            }
            if ((validContexts & ctxt) == 0) {
                abortParser("misplaced standard property: "
                            "'%s' is not valid in this context",
                            pname.c_str());
            }
        }

        // Call the appropriate builder method depending on the context
        // of the PROPERTY record.

        if (ctxt == PC_Element)
            builder->addElementProperty(prop);
        else if (ctxt == PC_Cell)
            builder->addCellProperty(prop);
        else {
            assert (ctxt == PC_File);
            builder->addFileProperty(prop);
        }
    }
    unreadLastRecord();
}



// If we skip a TEXT, XGEOMETRY, or XELEMENT record because the
// corresponding option in OasisParserOptions is false, we must skip the
// following PROPERTY records too.  But we must still call
// parsePropertyRecord() for each PROPERTY record because we must set
// the property-related modal variables.

void
ParserImpl::skipPropertyRecords()
{
    OasisRecord*  orecp;
    while (orecp = readNextRecord(), IsPropertyRecord(orecp)) {
        PropertyRecord*  recp = static_cast<PropertyRecord*>(orecp);
        delete parsePropertyRecord(recp);
    }
    unreadLastRecord();
}



// parsePropertyRecord -- make Property object from PROPERTY record's contents.
// Returns a pointer to the new Property object.  The caller should delete
// it when done with it.
//
// parsePropertyRecord() removes all the values from the PropertyRecord
// passed to it.  That is why the argument is not const.

Property*
ParserImpl::parsePropertyRecord (PropertyRecord* recp)
{
    // Section 31:  PROPERTY record
    // `28' prop-info-byte [reference-number | propname-string]
    //      [prop-value-count]  [ <property-value>* ]
    // `29'
    // prop-info-byte ::= UUUUVCNS

    assert (recp->recID == RID_PROPERTY
            ||  recp->recID == RID_PROPERTY_REPEAT);

    using namespace PropertyInfoByte;

    // Treat record type 29 (RID_PROPERTY_REPEAT) as a special case of
    // type 28 in which everything is reused: the name, the value list,
    // and the info-byte's StandardBit.

    int  infoByte;
    if (recp->recID == RID_PROPERTY)
        infoByte = recp->infoByte;
    else {
        bool  isStd = (modvars.isdef(ModalVars::MV_PROPERTY_IS_STANDARD)
                       && modvars.getPropertyIsStandard() );
        infoByte = ReuseValueBit | (isStd ? StandardBit : 0);
    }

    // Get the PropName using the name or refnum in the record, or pick
    // it up from the modal variable.

    PropName*   propName = getPropName(infoByte & NameExplicitBit,
                                       infoByte & RefnumBit,
                                       recp->name, recp->refnum);

    // If the S bit is set in the info-byte, the property is a standard
    // one.  Save the bit's value in a modal variable in case the next
    // PROPERTY record is of type 29.

    bool  isStd = (infoByte & StandardBit);
    modvars.setPropertyIsStandard(isStd);

    // Make a new Property object (the return value) and keep the
    // auto_ptr responsible for it until we return it.

    auto_ptr<Property>  autoProp(new Property(propName, isStd));
    Property*  prop = autoProp.get();

    // Reuse the previous property's value list or get it from the
    // record's contents, depending on the info-byte.  Before reusing
    // the previous property list, verify that it is defined.  UUUU
    // must be 0 in this case (paragraph 31.5).

    if (infoByte & ReuseValueBit) {     // V bit set
        if (! modvars.isdef(ModalVars::MV_LAST_VALUE_LIST))
            mvAbort("last-value-list");
        if (parserOptions.strictConformance  &&  (infoByte & ValueCountMask)) {
            abortParser("info-byte has invalid value %#x: "
                        "the V bit is set but UUUU is not 0",
                        infoByte);
        }

        // Copy the previous list's values to the new property.

        const PropValueVector&  lastVal(modvars.getLastValueList());
        PropValueVector::const_iterator  iter = lastVal.begin();
        PropValueVector::const_iterator  end  = lastVal.end();
        for ( ;  iter != end;  ++iter) {
            PropValue*  propval = *iter;
            prop->addValue(new PropValue(*propval));
        }
    }
    else {                              // V bit unset
        // Check all property values for validity, resolve references to
        // PropStrings, and transfer the values to our Property object
        // to take ownership of them.  Transferring the values saves the
        // expense of copying them here and deleting them in
        // OasisRecordReader.
        //
        PropValueVector::iterator  iter = recp->values.begin();
        PropValueVector::iterator  end  = recp->values.end();
        for ( ;  iter != end;  ++iter) {
            PropValue*  propval = *iter;
            fixPropValue(propval);
            prop->addValue(propval);
            *iter = Null;       // PropValue should not have two owners
        }
        recp->values.clear();   // remove all those Nulls

        // This makes a copy of each PropValue.
        modvars.setLastValueList(prop->getValueVector());
    }

    return (autoProp.release());
}



// fixPropValue -- validity-check property value and resolve ref to propstring

void
ParserImpl::fixPropValue (/*inout*/ PropValue* propval)
{
    PropValueType  valType = propval->getType();
    switch (valType) {
        case PV_AsciiString:
        case PV_BinaryString:
        case PV_NameString:
            // 13.10  Verify that string values do not appear when the
            // PropString dictionary is in strict mode.  Some tools
            // generate files with string values even when the
            // PROPSTRING table is marked strict, so do not enforce this
            // unless we are conforming to the spec.

            if (parserOptions.strictConformance && propStringDict.isStrict())
                abortParser("string property value forbidden in strict mode");

            if (valType == PV_AsciiString)
                verifyStringIsAscii(propval->getStringValue());
            else if (valType == PV_NameString)
                verifyStringIsName(propval->getStringValue());
            break;

        case PV_Ref_AsciiString:
        case PV_Ref_BinaryString:
        case PV_Ref_NameString: {
            Ulong  refnum = propval->getUnsignedIntegerValue();
            PropString*  propString =
                        propStringDict.lookupRefnum(refnum, !allNamesParsed);
            if (propString == Null)
                abortParser("no propstring with reference-number %lu", refnum);

            // Replace the refnum in the propval by ptr to the PropString.
            propval->setPropString(propString);

            // If we know the string (the PROPSTRING record has been
            // parsed), verify that it really is an a-string or an
            // n-string if the type of property value indicates that it
            // is.  Otherwise save propval in propValuesToCheck; we will
            // check it after we have parsed all <name> records.

            if (propString->hasName()) {
                if (valType == PV_Ref_AsciiString)
                    verifyStringIsAscii(propString->getName());
                else if (valType == PV_Ref_NameString)
                    verifyStringIsName(propString->getName());
            } else {
                propValuesToCheck.push_back(propval);
            }
            break;
        }

        default:
            // Nothing to check for the other kinds of property value
            break;
    }
}



//----------------------------------------------------------------------
//                      Repetition and PointList
//----------------------------------------------------------------------


// parseRepDimen -- convert raw dimension value from rep to internal value.
// This is a helper function for parseRepetition() below.  Wherever the
// repetition spec contains a dimension (i.e., the number of rows or
// columns or repetitions), the value stored in the file is 2 less than
// the actual dimension.  This function returns the actual value after
// verifying that it is not too large.

Ulong
ParserImpl::parseRepDimen (Ulong rawValue)
{
    // Restrict dimensions to max long (not Ulong) to simplify
    // checks for integer overflow.

    if (rawValue > MaxLong - 2)
        abortParser("dimension in repetition spec too large");
    return (rawValue + 2);
}



// parseRepetition -- convert raw repetition spec to internal form.
//   rawrep     the raw form of the repetition, with deltas and
//              unsigned values
//   rep        out: the internal form of rawrep is stored here
//
// Precondition:
//   rawrep.repType != Rep_ReusePrevious

void
ParserImpl::parseRepetition (const RawRepetition& rawrep,
                             /*out*/ Repetition* rep)
{
    // We need to sum the deltas in the raw repetition to get the
    // internal form.  Doing that may result in overflow_error
    // exceptions.  If one is thrown, we want the resulting error
    // message to include the standard prefix that abortParser() puts:
    // filename, record type, and file position.  So catch that
    // exception and pass its error message to abortParser().

    try {
        parseRepetition2(rawrep, rep);
    } catch (const overflow_error& exc) {
        abortParser("cannot parse repetition: %s", exc.what());
    }
}



void
ParserImpl::parseRepetition2 (const RawRepetition& rawrep,
                              /*out*/ Repetition* rep)
{
    const char  OffsetError[] =
            "cumulative offset in repetition spec too large";

    switch (rawrep.repType) {
        // 7.6.2  Type 0
        case Rep_ReusePrevious:
            // getRepetition() has already handled this case
            assert (false);
            break;

        // 7.6.3  Type 1
        // x-dimension y-dimension x-space y-space

        case Rep_Matrix: {
            Ulong  xdimen = parseRepDimen(rawrep.xdimen);
            Ulong  ydimen = parseRepDimen(rawrep.ydimen);

            // The item at the top-right corner of the matrix is at
            // (xspace*(xdimen-1), yspace*(ydimen-1)).
            // Make sure this position can be represented.
            // XXX: It doesn't seem to make sense to allow xspace==0
            // or yspace==0, but the spec doesn't forbid it.
            //
            if (rawrep.xspace > MaxLong/(xdimen-1)
                    ||  rawrep.yspace > MaxLong/(ydimen-1) )
                abortParser(OffsetError);

            rep->makeMatrix(xdimen, ydimen, rawrep.xspace, rawrep.yspace);
            break;
        }

        // 7.6.4  Type 2
        // x-dimension x-space

        case Rep_UniformX: {
            Ulong  dimen = parseRepDimen(rawrep.dimen);
            if (rawrep.xspace > MaxLong/(dimen-1))
                abortParser(OffsetError);
            rep->makeUniformX(dimen, rawrep.xspace);
            break;
        }

        // 7.6.5  Type 3
        // y-dimension y-space

        case Rep_UniformY: {
            Ulong  dimen = parseRepDimen(rawrep.dimen);
            if (rawrep.yspace > MaxLong/(dimen-1))
                abortParser(OffsetError);
            rep->makeUniformY(dimen, rawrep.yspace);
            break;
        }

        // 7.6.6  Type 4
        // x-dimension x-space_1 ... x-space_(n-1)
        //
        // The vector rawrep.spaces contains the spaces between
        // successive elements.  In the Repetition object we store the
        // offset of each element from the implicit zeroth element.
        // We also store explicitly the zeroth element, whose offset is
        // always 0.

        case Rep_VaryingX: {
            Ulong  dimen = parseRepDimen(rawrep.dimen);
            rep->makeVaryingX(dimen);

            vector<Ulong>::const_iterator  iter = rawrep.spaces.begin();
            vector<Ulong>::const_iterator  end  = rawrep.spaces.end();
            assert (static_cast<Ulong>(end - iter) == dimen-1);

            Ulong  offset = 0;                  // offset of next element
            rep->addVaryingXoffset(offset);     // implicit zeroth element
            for ( ;  iter != end;  ++iter) {
                Ulong  space = *iter;
                if (space > MaxLong - offset)
                    abortParser(OffsetError);
                offset += space;
                rep->addVaryingXoffset(offset);
            }
            break;
        }

        // 7.6.7  Type 5
        // x-dimension grid x-space_1 ... x-space_(n-1)
        //
        // Like Type 4, but multiply each space by grid before adding it.

        case Rep_GridVaryingX: {
            Ulong  dimen = parseRepDimen(rawrep.dimen);
            long  grid = ulongToLong(rawrep.grid);
            rep->makeGridVaryingX(dimen, grid);

            vector<Ulong>::const_iterator  iter = rawrep.spaces.begin();
            vector<Ulong>::const_iterator  end  = rawrep.spaces.end();
            assert (static_cast<Ulong>(end - iter) == dimen-1);

            Ulong  offset = 0;                  // offset of next element
            rep->addVaryingXoffset(offset);     // implicit zeroth element
            for ( ;  iter != end;  ++iter) {
                Ulong  space = *iter;
                if (space > (MaxLong - offset)/grid)
                    abortParser(OffsetError);
                offset += space * grid;
                rep->addVaryingXoffset(offset);
            }
            break;
        }

        // 7.6.8  Type 6
        // y-dimension y-space_1 ... y-space_(n-1)
        //
        // Types 6 and 7 are the same as types 4 and 5 with x replaced by y.

        case Rep_VaryingY: {
            Ulong  dimen = parseRepDimen(rawrep.dimen);
            rep->makeVaryingY(dimen);

            vector<Ulong>::const_iterator  iter = rawrep.spaces.begin();
            vector<Ulong>::const_iterator  end  = rawrep.spaces.end();
            assert (static_cast<Ulong>(end - iter) == dimen-1);

            Ulong  offset = 0;
            rep->addVaryingYoffset(offset);
            for ( ;  iter != end;  ++iter) {
                Ulong  space = *iter;
                if (space > MaxLong - offset)
                    abortParser(OffsetError);
                offset += space;
                rep->addVaryingYoffset(offset);
            }
            break;
        }

        // 7.6.9  Type 7
        // y-dimension grid y-space_1 ... y-space_(n-1)

        case Rep_GridVaryingY: {
            Ulong  dimen = parseRepDimen(rawrep.dimen);
            long  grid = ulongToLong(rawrep.grid);
            rep->makeGridVaryingY(dimen, grid);

            vector<Ulong>::const_iterator  iter = rawrep.spaces.begin();
            vector<Ulong>::const_iterator  end  = rawrep.spaces.end();
            assert (static_cast<Ulong>(end - iter) == dimen-1);

            Ulong  offset = 0;
            rep->addVaryingYoffset(offset);
            for ( ;  iter != end;  ++iter) {
                Ulong  space = *iter;
                if (space > (MaxLong - offset)/grid)
                    abortParser(OffsetError);
                offset += space * grid;
                rep->addVaryingYoffset(offset);
            }
            break;
        }

        // 7.6.10  Type 8
        // n-dimension m-dimension n-displacement m-displacement

        case Rep_TiltedMatrix: {
            Ulong  ndimen = parseRepDimen(rawrep.ndimen);
            Ulong  mdimen = parseRepDimen(rawrep.mdimen);
            Delta  ndisp = rawrep.getMatrixNdelta();
            Delta  mdisp = rawrep.getMatrixMdelta();

            // The corner of the tilted matrix opposite the origin is at
            //    x = (ndimen-1) * ndisp.x + (mdimen-1) * mdisp.x
            //    y = (ndimen-1) * ndisp.y + (mdimen-1) * mdisp.y
            // Make sure that this position can be represented.

            Ulong  nx = abs(ndisp.x),  ny = abs(ndisp.y);
            Ulong  mx = abs(mdisp.x),  my = abs(mdisp.y);
            if (nx > MaxLong/(ndimen-1)  ||  ny > MaxLong/(ndimen-1)
                    || mx > (MaxLong - (ndimen-1)*nx) / (mdimen-1)
                    || my > (MaxLong - (ndimen-1)*ny) / (mdimen-1) )
                abortParser(OffsetError);

            rep->makeTiltedMatrix(ndimen, mdimen, ndisp, mdisp);
            break;
        }

        // 7.6.11  Type 9
        // dimension displacement

        case Rep_Diagonal: {
            Ulong  dimen = parseRepDimen(rawrep.dimen);
            Delta  disp = rawrep.getDiagonalDelta();
            if (static_cast<Ulong>(abs(disp.x)) > MaxLong/(dimen-1)
                    ||  static_cast<Ulong>(abs(disp.y)) > MaxLong/(dimen-1))
                abortParser(OffsetError);

            rep->makeDiagonal(dimen, disp);
            break;
        }

        // 7.6.12  Type 10
        // dimension displacement_1 ... displacement_(n-1)

        case Rep_Arbitrary: {
            Ulong  dimen = parseRepDimen(rawrep.dimen);
            rep->makeArbitrary(dimen);

            vector<Delta>::const_iterator  iter = rawrep.deltas.begin();
            vector<Delta>::const_iterator  end  = rawrep.deltas.end();
            assert (static_cast<Ulong>(end - iter) == dimen - 1);

            Delta  offset(0, 0);
            rep->addDelta(offset);
            for ( ;  iter != end;  ++iter) {
                offset += *iter;        // may throw overflow_error
                rep->addDelta(offset);
            }
            break;
        }

        // 7.6.13  Type 11
        // dimension grid displacement_1 ... displacement_(n-1)
        //
        // Like Type 10, but multiply each displacement's components by
        // grid before adding to the cumulative offset.

        case Rep_GridArbitrary: {
            Ulong  dimen = parseRepDimen(rawrep.dimen);
            long  grid = ulongToLong(rawrep.grid);
            rep->makeGridArbitrary(dimen, grid);

            vector<Delta>::const_iterator  iter = rawrep.deltas.begin();
            vector<Delta>::const_iterator  end  = rawrep.deltas.end();
            assert (static_cast<Ulong>(end - iter) == dimen - 1);

            Delta  offset(0, 0);
            rep->addDelta(offset);
            for ( ;  iter != end;  ++iter) {
                Delta  delta(*iter);
                delta *= grid;          // may throw overflow_error
                offset += delta;        // may throw overflow_error
                rep->addDelta(offset);
            }
            break;
        }
    }
}



// parsePointList -- convert raw PointList for POLYGON/PATH into internal form.
// Stores the processed point-list in the ptlist argument.  The
// coordinates in the ptlist are relative to the starting point.
// The first point of the point-list is the starting point, which is
// always (0,0).

void
ParserImpl::parsePointList (const PointList&  rawPoints,
                            /*out*/ PointList* ptlist)
{
    // As with parseRepetition(), wrap the actual parsing function in a
    // try block so that any overflow_error exceptions thrown will get
    // abortParser's standard error prefix.

    try {
        parsePointList2(rawPoints,  ptlist);
    } catch (const overflow_error& exc) {
        abortParser("cannot parse point-list: %s", exc.what());
    }
}



void
ParserImpl::parsePointList2 (const PointList&  rawPoints,
                             /*out*/ PointList* ptlist)
{
    PointList::ListType  ltype = rawPoints.getType();
    ptlist->init(ltype);
        // The type of point-list remains the same.

    Delta  point(0, 0);
        // Position of the each point relative to the first.  This is
        // the sum of the deltas seen so far, and is what is stored in
        // the PointList.

    ptlist->addPoint(point);
        // The initial vertex is not stored in the file but our
        // convention is to store it in the PointList.

    PointList::const_iterator  vertIter = rawPoints.begin();
    PointList::const_iterator  vertEnd  = rawPoints.end();

    // In the raw point-list, each point is the delta with respect to the
    // previous point.  The internal convention is to specify each point's
    // coordinates as offsets with respect to the first point.  Thus we
    // need to accumulate the deltas, being careful to check for
    // integer overflow whenever we add deltas.

    switch (ltype) {
        // 7.7.2 and 7.7.3  Types 0 and 1
        // Implicit manhattan delta, horizontal-first and vertical-first
        // These two types use 1-deltas, which in the raw point-list are
        // stored in Delta's x member.
        //
        case PointList::ManhattanHorizFirst:
        case PointList::ManhattanVertFirst: {
            bool horiz = (ltype == PointList::ManhattanHorizFirst);
            for ( ;  vertIter != vertEnd;  ++vertIter) {
                long  offset = vertIter->x;
                if (offset == 0) {
                    // 7.7.8:  successive coincident points are not permitted
                    abortParser("zero-length edge in point-list of type %d",
                                ltype);
                }
                if (horiz)
                    point.x = checkedPlus(point.x, offset);
                else
                    point.y = checkedPlus(point.y, offset);
                ptlist->addPoint(point);
                horiz = ! horiz;
            }
            break;
        }

        // 7.7.4  Type 2  Explicit manhattan delta
        // 7.7.5  Type 3  Explicit octangular delta
        // 7.7.6  Type 4  Explicit all-angle delta
        // These differ only in the storage format (2-deltas, 3-deltas,
        // and g-deltas respectively).  At this stage they are all the same.

        case PointList::Manhattan:
        case PointList::Octangular:
        case PointList::AllAngle:
            for ( ;  vertIter != vertEnd;  ++vertIter) {
                point += *vertIter;     // may throw overflow_error
                ptlist->addPoint(point);
            }
            break;

        // 7.7.7  Type 5
        // Explicit all-angle double-delta
        // Each delta in the file is a delta of deltas, i.e., the
        // difference between the current delta and the previous one.

        case PointList::AllAngleDoubleDelta: {
            Delta  delta(0, 0);         // cumulative delta
            for ( ;  vertIter != vertEnd;  ++vertIter) {
                delta += *vertIter;     // may throw overflow_error
                point += delta;         // may throw overflow_error
                ptlist->addPoint(point);
            }
            break;
        }
    }
}



// makePolygon -- verify point-list forms polygon and add any implicit point.
// Adds the final implicit point for point lists of type 0 and 1
// (ManhattanHorizFirst and ManhattanVertFirst).

void
ParserImpl::makePolygon (/*inout*/ PointList* ptlist)
{
    PointList::ListType  ltype = ptlist->getType();

    // The point-list has at least one vertex, (0, 0), because
    // parsePointList() adds the implicit origin vertex.  So all calls
    // below to ptlist->back() are valid.

    switch (ltype) {
        // 7.7.2 and 7.7.3
        // For Manhattan polygons with alternating horizontal and
        // vertical edges, add the final (implicit) vertex.  Manhattan
        // polygons have an even number of vertices, so verify first
        // that the number of points in the file (without the two
        // implicit points) is even and >= 2.

        case PointList::ManhattanHorizFirst:
        case PointList::ManhattanVertFirst: {
            Ulong  numVert = ptlist->numPoints() - 1;
            if ((numVert & 0x1) != 0  ||  numVert < 2) {
                abortParser("invalid number of vertices %lu"
                            " for polygon point-list of type %d",
                            numVert, ltype);
            }

            // If the first edge is horizontal, the last edge is vertical
            // and the last point is at the same X position as the first.

            Delta  lastPoint = ptlist->back();
            if (lastPoint.x == 0  ||  lastPoint.y == 0)
                abortParser("zero-length edge in point-list of type %d",ltype);
            if (ltype == PointList::ManhattanHorizFirst)
                lastPoint.x = 0;
            else
                lastPoint.y = 0;
            ptlist->addPoint(lastPoint);
            break;
        }

        // For the remaining types of point-list, the spec says nothing
        // about enforcing a minimum number of vertices.

        // 7.7.4
        case PointList::Manhattan:
            if (! ptlist->back().isManhattan()) {
                abortParser("final displacement not manhattan in "
                            "polygon point-list of type %d", ltype);
            }
            break;

        // 7.7.5
        case PointList::Octangular:
            if (! ptlist->back().isOctangular()) {
                abortParser("final displacement not octangular "
                            "in polygon point-list of type %d", ltype);
            }
            break;

        // Nothing to verify or change for these types of point-lists.
        case PointList::AllAngle:
        case PointList::AllAngleDoubleDelta:
            break;
    }
}



//----------------------------------------------------------------------
//                          Modal Variables
//----------------------------------------------------------------------

// Methods to read data that become part of the modal state.  Most of
// these functions take a boolean argument 'infoBit' and the (possibly
// undefined) input value from the current record.  If infoBit is true,
// the input value must be defined and the function returns it after
// saving a copy in the appropriate modal variable.  If infoBit is
// false, the function returns the value that is in the modal variable,
// or aborts the parse if the modal variable is undefined.
//
// The first six modal-variable functions -- to read placement-[xy],
// geometry-[xy], and text-[xy] -- are special for two reasons:
//
//   - Since the modal variables are always defined, there is no need
//     to check first with ModalVars::isdef().
//
//   - If modvars.xyRelative() is true, the input value is relative
//     to the modal variable, which must be added to get the absolute
//     value.  These methods return the absolute position.  Note that
//     all arithmetic operations must be checked for integer overflow.


// checkedPlus -- add two longs with checks for overflow.
// Returns x+y if there is no overflow.
//
// This is more or less the same as CheckedPlus<long>() from misc/arith.h.
// We need a special version because we cannot just throw
// overflow_error.  The error message in all parser exceptions must
// include the standard prefix that abortParser() puts.

long
ParserImpl::checkedPlus (long x, long y)
{
    if ((x > 0  &&  y > 0  &&  x > LONG_MAX - y)
            ||  (x < 0  &&  y < 0  &&  x < -LONG_MAX - y))
        abortParser("integer overflow while computing %ld + %ld", x, y);
    return (x + y);
}



long
ParserImpl::getPlacementX (bool infoBit, long x)
{
    if (infoBit) {
        if (modvars.xyIsRelative())
            x = checkedPlus(x, modvars.getPlacementX());
        modvars.setPlacementX(x);
    } else
        x = modvars.getPlacementX();

    return x;
}



long
ParserImpl::getPlacementY (bool infoBit, long y)
{
    if (infoBit) {
        if (modvars.xyIsRelative())
            y = checkedPlus(y, modvars.getPlacementY());
        modvars.setPlacementY(y);
    } else
        y = modvars.getPlacementY();

    return y;
}



long
ParserImpl::getGeometryX (bool infoBit, long x)
{
    if (infoBit) {
        if (modvars.xyIsRelative())
            x = checkedPlus(x, modvars.getGeometryX());
        modvars.setGeometryX(x);
    } else
        x = modvars.getGeometryX();

    return x;
}



long
ParserImpl::getGeometryY (bool infoBit, long y)
{
    if (infoBit) {
        if (modvars.xyIsRelative())
            y = checkedPlus(y, modvars.getGeometryY());
        modvars.setGeometryY(y);
    } else
        y = modvars.getGeometryY();

    return y;
}



long
ParserImpl::getTextX (bool infoBit, long x)
{
    if (infoBit) {
        if (modvars.xyIsRelative())
            x = checkedPlus(x, modvars.getTextX());
        modvars.setTextX(x);
    } else
        x = modvars.getTextX();

    return x;
}



long
ParserImpl::getTextY (bool infoBit, long y)
{
    if (infoBit) {
        if (modvars.xyIsRelative())
            y = checkedPlus(y, modvars.getTextY());
        modvars.setTextY(y);
    } else
        y = modvars.getTextY();

    return y;
}



Ulong
ParserImpl::getLayer (bool infoBit, Ulong layer)
{
    if (infoBit)
        modvars.setLayer(layer);
    else if (modvars.isdef(ModalVars::MV_LAYER))
        layer = modvars.getLayer();
    else
        mvAbort("layer");

    return layer;
}



Ulong
ParserImpl::getDatatype (bool infoBit, Ulong datatype)
{
    if (infoBit)
        modvars.setDatatype(datatype);
    else if (modvars.isdef(ModalVars::MV_DATATYPE))
        datatype = modvars.getDatatype();
    else
        mvAbort("datatype");

    return datatype;
}



Ulong
ParserImpl::getTextlayer (bool infoBit, Ulong textlayer)
{
    if (infoBit)
        modvars.setTextlayer(textlayer);
    else if (modvars.isdef(ModalVars::MV_TEXTLAYER))
        textlayer = modvars.getTextlayer();
    else
        mvAbort("textlayer");

    return textlayer;
}



Ulong
ParserImpl::getTexttype (bool infoBit, Ulong texttype)
{
    if (infoBit)
        modvars.setTexttype(texttype);
    else if (modvars.isdef(ModalVars::MV_TEXTTYPE))
        texttype = modvars.getTexttype();
    else
        mvAbort("texttype");

    return texttype;
}



Uint
ParserImpl::getCTrapezoidType (bool infoBit, Ulong ctrapType)
{
    if (infoBit) {
        if (! Trapezoid::ctrapezoidTypeIsValid(ctrapType))
            abortParser("invalid ctrapezoid type %lu", ctrapType);
        modvars.setCTrapezoidType(ctrapType);
    } else if (modvars.isdef(ModalVars::MV_CTRAPEZOID_TYPE)) {
        ctrapType = modvars.getCTrapezoidType();
    } else
        mvAbort("ctrapezoid-type");

    return ctrapType;
}



// Limit the values of the geometry-related unsigned-integers width,
// height, path-halfwidth and circle-radius to MaxLong (not MaxUlong)
// to simplify checks for integer overflow.


long
ParserImpl::getGeometryWidth (bool infoBit, Ulong uwidth)
{
    long        width;

    if (infoBit) {
        width = ulongToLong(uwidth);
        modvars.setGeometryWidth(width);
    } else if (modvars.isdef(ModalVars::MV_GEOMETRY_WIDTH)) {
        width = modvars.getGeometryWidth();
    } else {
        mvAbort("geometry-w");
        width = 0;      // make gcc happy
    }

    return width;
}



long
ParserImpl::getGeometryHeight (bool infoBit, Ulong uheight)
{
    long        height;

    if (infoBit) {
        height = ulongToLong(uheight);
        modvars.setGeometryHeight(height);
    } else if (modvars.isdef(ModalVars::MV_GEOMETRY_HEIGHT)) {
        height = modvars.getGeometryHeight();
    } else {
        mvAbort("geometry-h");
        height = 0;     // make gcc happy
    }

    return height;
}



long
ParserImpl::getPathHalfwidth (bool infoBit, Ulong uhalfwidth)
{
    long        halfwidth;

    if (infoBit) {
        halfwidth = ulongToLong(uhalfwidth);
        modvars.setPathHalfwidth(halfwidth);
    } else if (modvars.isdef(ModalVars::MV_PATH_HALFWIDTH)) {
        halfwidth = modvars.getPathHalfwidth();
    } else {
        mvAbort("path-halfwidth");
        halfwidth = 0;  // make gcc happy
    }

    return halfwidth;
}



long
ParserImpl::getRadius (bool infoBit, Ulong uradius)
{
    long        radius;

    if (infoBit) {
        radius = ulongToLong(uradius);
        modvars.setCircleRadius(radius);
    } else if (modvars.isdef(ModalVars::MV_CIRCLE_RADIUS)) {
        radius = modvars.getCircleRadius();
    } else {
        mvAbort("circle-radius");
        radius = 0;     // make gcc happy
    }

    return radius;
}



// readStartExtension -- get start-extension for PATH record.
//   selector   value of the two SS bits from the extension-scheme byte
//              in the PATH record.  Must be in the range 0..3.
//   halfwidth  the halfwidth of this path.  This value is used as the
//              start extension when selector is 2 (binary 10).
//   extn       the extension in the PATH record.  This is defined only
//              if selector==3.

long
ParserImpl::getStartExtension (Uint selector, long halfwidth, long extn)
{
    // Table 27-1
    // SS Bits  Description
    // -------------------------------------------------------------
    //   00     Use path-start-extension modal variable
    //   01     Use flush (zero-length) extension at starting vertex
    //   10     Use path-halfwidth extension at starting vertex
    //   11     Use explicit start-extension at starting vertex

    assert (selector < 4);
    using namespace PathInfoByte;

    switch (selector) {
        case ReuseLastExtn:
            if (modvars.isdef(ModalVars::MV_PATH_START_EXTENSION))
                extn = modvars.getPathStartExtension();
            else
                mvAbort("path-start-extension");
            break;

        case FlushExtn:      extn = 0;          break;
        case HalfwidthExtn:  extn = halfwidth;  break;
        case ExplicitExtn:   /*nothing*/        break;
    }

    modvars.setPathStartExtension(extn);
    return extn;
}



// readEndExtension -- get end-extension for PATH record.
// Analogous to getStartExtension() above.  selector is the value
// of the EE bits.

long
ParserImpl::getEndExtension (Uint selector, long halfwidth, long extn)
{
    assert (selector < 4);
    using namespace PathInfoByte;

    switch (selector) {
        case ReuseLastExtn:
            if (modvars.isdef(ModalVars::MV_PATH_END_EXTENSION))
                extn = modvars.getPathEndExtension();
            else
                mvAbort("path-end-extension");
            break;

        case FlushExtn:      extn = 0;          break;
        case HalfwidthExtn:  extn = halfwidth;  break;
        case ExplicitExtn:   /*nothing*/        break;
    }

    modvars.setPathEndExtension(extn);
    return extn;
}



// Some tools generate OASIS files with PROPERTY records that contain
// propname-strings even when the PROPNAME table is marked strict.  So
// in getPropName() we disable the strictness check unless we are
// conforming to the spec.  For consistency we disable the similar
// checks in getPlacementCell() and getTextString().



// getPlacementCell -- get the cell referenced in a PLACEMENT record
//   isExplicit   the CellExplicit bit from the info-byte.
//              true => reference specified explicitly;
//                      either name or refnum is valid
//              false => both name and refnum are undefined;
//                       get value from the modal variable placement-cell
//   isRefnum   used only when isExplicit is true.
//              true => refnum is valid; false => name is valid
//   name       the cellname field from PlacementRecord
//   refnum     the refnum field from PlacementRecord.
// Returns a pointer to the CellName object for the cell referenced.

CellName*
ParserImpl::getPlacementCell (bool isExplicit, bool isRefnum,
                              const string& name, Ulong refnum)
{
    CellName*   cellName;

    if (isExplicit) {
        if (isRefnum) {
            if ((cellName = cellNameDict.lookupRefnum(refnum, false)) == Null)
                abortParser("reference-number %lu not defined", refnum);
        } else {
            // 13.10
            if (parserOptions.strictConformance && cellNameDict.isStrict())
                abortParser("cellname-string forbidden in strict mode");
            verifyStringIsName(name);
            cellName = cellNameDict.lookupName(name, true);
                // XXX: What should we do if this cell is never defined?
                // Treat it as external?
        }
        modvars.setPlacementCell(cellName);
    } else if (modvars.isdef(ModalVars::MV_PLACEMENT_CELL)) {
        cellName = modvars.getPlacementCell();
    } else {
        mvAbort("placement-cell");
        cellName = Null;        // make gcc happy
    }

    return cellName;
}



// getTextString -- get the text-string referenced in a TEXT record
//   isExplicit   the TextExplicit bit from the info-byte.
//              true => reference specified explicitly;
//                      either name or refnum is valid
//              false => both name and refnum are undefined;
//                       get value from the modal variable text-string
//   isRefnum   used only when isExplicit is true.
//              true => refnum is valid; false => name is valid
//   name       the text field from the TextRecord
//   refnum     the refnum field from the TextRecord
// Returns a pointer to the TextString object for the text-string.

TextString*
ParserImpl::getTextString (bool isExplicit, bool isRefnum,
                           const string& text, Ulong refnum)
{
    TextString* textString;

    // If the TEXT record has a refnum, we must have a TextString object
    // with that refnum.  There cannot be forward references because
    // TEXT records are parsed only after all names have been parsed.
    // Hence the `false' argument to lookupRefnum(), meaning "if it
    // doesn't exist, don't create it".
    //
    // If the TEXT record has a string, and it's okay to have one,
    // create an unregistered TextString object.  This object will not
    // be registered with the OasisBuilder but will exist as long as
    // this parser.  Anyway we cannot delete it while modvars keeps
    // a pointer to it.

    if (isExplicit) {
        if (isRefnum) {
            textString = textStringDict.lookupRefnum(refnum, false);
            if (textString == Null)
                abortParser("reference-number %lu not defined", refnum);
        } else {
            // 13.10
            if (parserOptions.strictConformance && textStringDict.isStrict())
                abortParser("text-string forbidden in strict mode");
            verifyStringIsAscii(text);
            textString = makeTextString(text);
        }
        modvars.setTextString(textString);
    } else if (modvars.isdef(ModalVars::MV_TEXT_STRING)) {
        textString = modvars.getTextString();
    } else {
        mvAbort("text-string");
        textString = Null;      // make gcc happy
    }

    return textString;
}



// getPropName -- resolve reference to propname or refnum in PROPERTY record
// Same arguments as getTextString() above.

PropName*
ParserImpl::getPropName (bool isExplicit, bool isRefnum,
                         const string& name, Ulong refnum)
{
    PropName*   propName;

    // As in parseCellRecord(), we allow undefined refnums (forward
    // references) only during the first phase, when allNamesParsed is
    // false.
    //
    // If the PROPERTY record contains a property name instead of a
    // refnum, we create an unregistered PropName object.  This is
    // different from what we do in getPlacementCell() and
    // getTextString(), where we look up the name in the dictionary,
    // creating a new entry when needed.  We do not do that here because
    // that might result in conflicting PropNames in propNameDict.
    // Consider this sequence of records:
    //
    //     CELLNAME "foo"
    //     PROPERTY name "S_CELL_OFFSET"  values 1 8 1000
    //     CELLNAME "bar"
    //     PROPERTY refnum 42  values 1 8 2000
    //     PROPNAME "S_CELL_OFFSET" 42
    //
    // If we created new dictionary entries for names in PROPERTY
    // records, this would result in the following:
    //   - a PropName in propNameDict for S_CELL_OFFSET with no refnum;
    //   - another PropName in propNameDict for refnum 42 with no name;
    //   - an abort while processing the PROPNAME because
    //     RefNameDict::add() tried to set the name for the second
    //     PropName to S_CELL_OFFSET, for which another PropName exists.
    //
    // We do not have the same problem in getPlacementCell() and
    // getTextString() because we process all CELLNAME and TEXTSTRING
    // records before any PLACEMENT or TEXT record.  But we cannot
    // always avoid forward references for properties because we process
    // a <name> record's PROPERTY records along with the <name> record.
    //
    // Also see the entry 'Property names and PROPNAME records' in
    // DesignNotes.

    if (isExplicit) {
        if (isRefnum) {
            propName = propNameDict.lookupRefnum(refnum, !allNamesParsed);
            if (propName == Null)
                abortParser("PROPNAME reference-number %lu not defined",
                            refnum);
        } else {
            // 13.10
            if (parserOptions.strictConformance && propNameDict.isStrict())
                abortParser("propname-string forbidden in strict mode");
            verifyStringIsName(name);
            propName = makePropName(name);
        }
        modvars.setLastPropertyName(propName);
    } else if (modvars.isdef(ModalVars::MV_LAST_PROPERTY_NAME)) {
        propName = modvars.getLastPropertyName();
    } else {
        mvAbort("last-property-name");
        propName = Null;        // make gcc happy
    }

    return propName;
}



// getPolygonPoints -- get the point-list for a POLYGON record
//   infoBit    the P bit from the POLYGON record's info-byte
//   rawPoints  the point-list as stored in the file and read by
//              OasisRecordReader.
// Returns a reference to the processed point-list to be passed to the
// builder.

const PointList&
ParserImpl::getPolygonPoints (bool infoBit, const PointList& rawPoints)
{
    // If the file contained a point-list, rawPoints is defined.
    // Convert the raw input into the internal form.  To avoid yet
    // another copy, create the output directly in the modal variable.
    // Then verify that the point-list meets the polygon constraints and
    // add any implicit vertices.

    if (infoBit) {
        PointList& ptlist(modvars.getPolygonPointsRef());
        parsePointList(rawPoints, &ptlist);
        makePolygon(&ptlist);
        modvars.definePolygonPoints();
        return ptlist;          // return ref to modal variable
    }

    // If the file did not contain a point-list, use the modal variable
    // if it is defined.

    if (! modvars.isdef(ModalVars::MV_POLYGON_POINTS))
        mvAbort("polygon-points");
    return modvars.getPolygonPoints();
}



// getPathPoints -- get the point-list for a PATH record
// Like getPolygonPoints() above, but does not convert the point-list
// into a polygon.

const PointList&
ParserImpl::getPathPoints (bool infoBit, const PointList& rawPoints)
{
    if (infoBit) {
        PointList& ptlist(modvars.getPathPointsRef());
        parsePointList(rawPoints, &ptlist);
        modvars.definePathPoints();
        return ptlist;
    }
    if (! modvars.isdef(ModalVars::MV_PATH_POINTS))
        mvAbort("path-points");
    return modvars.getPathPoints();
}



const Repetition*
ParserImpl::getRepetition (bool infoBit, const RawRepetition& rawrep)
{
    // Repetition is not like the other modal variables.  If the
    // repetition bit is not set in the info-byte, it means that there
    // is no repetition at all, not that the repetition should be copied
    // from the modal variable.  We use Null to mean no repetition.

    if (! infoBit)
        return Null;

    // If the repetition type in the file is 0 (Rep_ReusePrevious), return
    // a pointer to the modal variable after ensuring that it is defined.

    Repetition&  rep(modvars.getRepetitionRef());
    if (rawrep.repType == Rep_ReusePrevious) {
        if (modvars.isdef(ModalVars::MV_REPETITION))
            return (&rep);
        mvAbort("repetition");
    }

    // To avoid copying the parsed repetition object, build it directly
    // in the modal variable, mark the modal variable as being defined,
    // and return a pointer to it.

    parseRepetition(rawrep, &rep);
    modvars.defineRepetition();
    return (&rep);
}



// xyRelative -- set xy-mode
// This is called when an XYABSOLUTE or XYRELATIVE record is parsed.

void
ParserImpl::xyRelative (bool yes)
{
    modvars.xySetRelative(yes);
}



//----------------------------------------------------------------------
// Verification functions
// The functions below check something and abort the parse if the
// check fails.


// verifyStringIsAscii -- verify that string has only printable ASCII chars.
// This function is invoked wherever the spec calls for an a-string.

void
ParserImpl::verifyStringIsAscii (const string& str)
{
    // Some OASIS files have control characters in a-strings, so we
    // allow all non-NUL ASCII characters unless we are conforming to
    // the spec.

    Uint  minValidChar, maxValidChar;
    if (parserOptions.strictConformance) {
        minValidChar = 0x20;
        maxValidChar = 0x7e;
    } else {
        minValidChar = 0x1;
        maxValidChar = 0x7f;
    }

    char        charbuf[10];    // for printable representations of chars

    const char*  cp = str.data();
    const char*  end = cp + str.size();
    for ( ;  cp != end;  ++cp) {
        Uchar  uch = static_cast<Uchar>(*cp);
        if (uch < minValidChar  ||  uch > maxValidChar) {
            CharToString(charbuf, sizeof charbuf, uch);
            abortParser("invalid character '%s' in a-string", charbuf);
        }
    }
}



// verifyStringIsName -- verify that string is a valid name.
// A valid name is non-empty and contains only graphic ASCII chars.
// This function is invoked wherever the spec calls for an n-string.

void
ParserImpl::verifyStringIsName (const string& str)
{
    char        charbuf[10];    // for printable representations of chars

    const char*  cp = str.data();
    const char*  end = cp + str.size();

    if (cp == end)
        abortParser("zero-length n-string");
    for ( ;  cp != end;  ++cp) {
        Uchar  uch = static_cast<Uchar>(*cp);
        if (uch < 0x21 || uch > 0x7e) {
            CharToString(charbuf, sizeof charbuf, uch);
            abortParser("invalid character '%s' in n-string", charbuf);
        }
    }
}



// verifyExclusiveRecords -- abort if mutually-exclusive record types appear.
//   currRecID  the current record's record-ID.  It must be the same as
//              rid or rid2.
//   rid, rid2  the record-IDs of the two mutually-exclusive types
//
// OASIS specifies several pairs of mutually-exclusive record types,
// e.g.  RID_CELLNAME and RID_CELLNAME_R.  No file should contain
// records of both types.  This function aborts the parse if both record
// types have appeared.

void
ParserImpl::verifyExclusiveRecords (Uint currRecID,
                                    RecordID rid, RecordID rid2)
{
    BOOST_STATIC_ASSERT (RID_MaxID < numeric_limits<Ullong>::digits);

    recordsSeen |= (1ull << currRecID);
    Ullong  bothBits = (1ull << rid) | (1ull << rid2);
    if ((recordsSeen & bothBits) == bothBits) {
        abortParser("file contains mutually exclusive record types %d and %d",
                    rid, rid2);
    }
}


//----------------------------------------------------------------------
// Handling errors


// mvAbort -- abort parse because the file used an undefined modal variable.
//   varName    the name of the undefined modal variable

void
ParserImpl::mvAbort (const char* varName)
{
    char  buf[100];
    SNprintf(buf, sizeof buf, "modal variable %s used while undefined",
             varName);
    abortParser("%s", buf);
}



// abortParser -- throw runtime_error for unrecoverable error
//   fmt        printf() format string for error message
//   ...        args, if any, for the format string
// The formatted error message can be retrieved from the exception by
// using exception::what().

void
ParserImpl::abortParser (const char* fmt, ...)
{
    char  msgbuf[256];

    va_list  ap;
    va_start(ap, fmt);
    formatMessage(msgbuf, sizeof msgbuf, "", fmt, ap);
    va_end(ap);

    ThrowRuntimeError("%s", msgbuf);
}



// warn -- warn about minor error
//   fmt        printf() format string for error message
//   ...        args, if any, for the format string

void
ParserImpl::warn (const char* fmt, ...)
{
    char  msgbuf[256];

    va_list  ap;
    va_start(ap, fmt);
    formatMessage(msgbuf, sizeof msgbuf, "warning: ", fmt, ap);
    va_end(ap);

    if (warnHandler != Null)
        warnHandler(msgbuf);
}



// formatMessage -- format error/warning message in buffer
//   buf        the buffer in which the message is to be formatted
//   bufsize    bytes available in buf
//   msgPrefix  string to put in the message between the context and
//              the message proper
//   fmt        printf() format string for message
//   ap         varargs arg pointer for the format arguments, if any
//
// The context string at the beginning of the message has one of these forms:
//   if currRecord == Null:  file 'foo'
//   if currRecord != Null:  file 'foo', <record-position>
//
// <record-position> in turn has one of these forms, depending on whether
// the record is in a CBLOCK (nn is the record-ID of record FOO):
//   FOO (nn) record at offset NNN
//   FOO (nn) record at uncompressed offset NNN in CBLOCK at offset MMM

void
ParserImpl::formatMessage (/*out*/ char* buf, size_t bufsize,
                           const char*  msgPrefix,
                           const char*  fmt,
                           va_list  ap)
{
    Uint  n;

    if (currRecord == Null) {
        n = SNprintf(buf, bufsize, "file '%s': ", filename.c_str());
    } else {
        char  posbuf[100];
        currRecord->recPos.print(posbuf, sizeof posbuf);
        n = SNprintf(buf, bufsize, "file '%s', %s(%d) record at %s: ",
                     filename.c_str(),
                     GetRecordErrName(currRecord->recID), currRecord->recID,
                     posbuf);
    }
    if (n < bufsize - 1)
        n += SNprintf(buf + n, bufsize - n, "%s", msgPrefix);
    if (n < bufsize - 1)
        VSNprintf(buf + n, bufsize - n, fmt, ap);
}



//======================================================================
//                              OasisParser
//======================================================================

// OasisParser is the handle class visible to the application.
// It forwards all requests to its instance of the body class ParserImpl.


OasisParser::OasisParser (const char* fname, WarningHandler warner,
                          const OasisParserOptions& options)
{
    impl = new ParserImpl(fname, warner, options);
}


OasisParser::~OasisParser() {
    delete impl;
}


void
OasisParser::validateFile() {
    impl->validateFile();
}


Validation
OasisParser::parseValidation() {
    return (impl->parseValidation());
}


void
OasisParser::parseFile (OasisBuilder* builder) {
    impl->parseFile(builder);
}


bool
OasisParser::parseCell (const char* cellname, OasisBuilder* builder) {
    return (impl->parseCell(cellname, builder));
}


}  // namespace Oasis
